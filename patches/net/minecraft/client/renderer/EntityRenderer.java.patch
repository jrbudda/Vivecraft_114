--- a/net/minecraft/client/renderer/EntityRenderer.java
+++ b/net/minecraft/client/renderer/EntityRenderer.java
@@ -1,7 +1,20 @@
 package net.minecraft.client.renderer;
 
 import com.google.gson.JsonSyntaxException;
+import com.mtbs3d.minecrift.gameplay.OpenVRPlayer;
+import com.mtbs3d.minecrift.gameplay.screenhandlers.GuiHandler;
+import com.mtbs3d.minecrift.gameplay.screenhandlers.KeyboardHandler;
+import com.mtbs3d.minecrift.gameplay.screenhandlers.RadialHandler;
+import com.mtbs3d.minecrift.gameplay.trackers.BowTracker;
+import com.mtbs3d.minecrift.provider.MCOpenVR;
+import com.mtbs3d.minecrift.render.renderPass;
+import com.mtbs3d.minecrift.settings.VRSettings;
+
+import de.fruitfly.ovr.enums.EyeType;
+
 import java.io.IOException;
+import java.nio.FloatBuffer;
+import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.List;
@@ -15,12 +28,20 @@
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.entity.AbstractClientPlayer;
+import net.minecraft.client.entity.EntityPlayerSP;
 import net.minecraft.client.gui.FontRenderer;
 import net.minecraft.client.gui.GuiChat;
 import net.minecraft.client.gui.GuiDownloadTerrain;
 import net.minecraft.client.gui.GuiMainMenu;
+import net.minecraft.client.gui.GuiScreen;
+import net.minecraft.client.gui.GuiWinGame;
 import net.minecraft.client.gui.MapItemRenderer;
+import net.minecraft.client.gui.inventory.GuiContainer;
+import net.minecraft.client.main.Main;
 import net.minecraft.client.particle.ParticleManager;
+import net.minecraft.client.renderer.GlStateManager.DestFactor;
+import net.minecraft.client.renderer.GlStateManager.FogMode;
+import net.minecraft.client.renderer.GlStateManager.SourceFactor;
 import net.minecraft.client.renderer.block.model.ItemCameraTransforms;
 import net.minecraft.client.renderer.chunk.RenderChunk;
 import net.minecraft.client.renderer.culling.ClippingHelper;
@@ -32,6 +53,7 @@
 import net.minecraft.client.renderer.tileentity.TileEntityRendererDispatcher;
 import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
 import net.minecraft.client.resources.I18n;
+import net.minecraft.client.shader.Framebuffer;
 import net.minecraft.client.shader.ShaderGroup;
 import net.minecraft.client.shader.ShaderLinkHelper;
 import net.minecraft.crash.CrashReport;
@@ -48,6 +70,7 @@
 import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.fluid.IFluidState;
 import net.minecraft.init.Blocks;
+import net.minecraft.init.Items;
 import net.minecraft.init.MobEffects;
 import net.minecraft.init.Particles;
 import net.minecraft.init.SoundEvents;
@@ -62,6 +85,7 @@
 import net.minecraft.util.BlockRenderLayer;
 import net.minecraft.util.EntitySelectors;
 import net.minecraft.util.EnumFacing;
+import net.minecraft.util.EnumHand;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.ScreenShotHelper;
 import net.minecraft.util.SoundCategory;
@@ -71,7 +95,9 @@
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.util.math.RayTraceFluidMode;
 import net.minecraft.util.math.RayTraceResult;
+import net.minecraft.util.math.RayTraceResult.Type;
 import net.minecraft.util.math.Vec3d;
+import net.minecraft.util.math.Vec3i;
 import net.minecraft.util.math.shapes.VoxelShape;
 import net.minecraft.util.text.Style;
 import net.minecraft.util.text.TextComponentString;
@@ -88,13 +114,20 @@
 import net.optifine.gui.GuiChatOF;
 import net.optifine.reflect.Reflector;
 import net.optifine.reflect.ReflectorForge;
+import net.optifine.shaders.Program;
 import net.optifine.shaders.Shaders;
 import net.optifine.shaders.ShadersRender;
 import net.optifine.util.TextureUtils;
 import net.optifine.util.TimedEvent;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.lwjgl.opengl.EXTTextureFilterAnisotropic;
+import org.lwjgl.opengl.GL;
 import org.lwjgl.opengl.GL11;
+import org.lwjgl.opengl.GL12;
+import org.lwjgl.opengl.GL14;
+import org.lwjgl.opengl.GL30;
+import org.lwjgl.opengl.NVFogDistance;
 
 public class EntityRenderer implements AutoCloseable, IResourceManagerReloadListener
 {
@@ -176,6 +209,43 @@
     public int loadVisibleChunksCounter = -1;
     public static final int loadVisibleChunksMessageId = 201435902;
 
+    /** MINECRIFT */
+    public static float MAX_CROSSHAIR_DISTANCE = 64f;
+    public int renderpass = 0;
+
+    public float crossX;
+    public float crossY;
+    public float crossZ;
+
+    private boolean eyeCollision = false;
+    Block eyeCollisionBlock;
+    public float minClipDistance = 0.05f;
+    public Vec3d crossVec;
+    private FloatBuffer matrixBuffer = GLAllocation.createDirectFloatBuffer(16);
+    public Matrix4f thirdPassProjectionMatrix = new Matrix4f();
+
+    public boolean menuWorldFastTime;
+    public boolean inwater, inportal, inblock, onfire;
+    public float inBlock = 0;
+    Frustum currentFrustum = new Frustum();
+    private boolean always_true = true;
+
+    //For RenderViewEntity Overrides
+	public double rveX, rveY, rveZ, rvelastX, rvelastY, rvelastZ, rveprevX, rveprevY, rveprevZ;
+	private float rveyaw, rvepitch, rvelastyaw, rvelastpitch, rveHeight;
+	private boolean cached;
+	
+	//For Poly Rendering
+  	private int polyblendsrc, polyblenddst;
+  	private Program prog;
+  	private boolean polyblend, polytex, polylight, polycull;
+  	
+  	//Teleporter
+  	Vec3i tpUnlimitedColor = new Vec3i((byte)173, (byte)216, (byte)230);
+  	Vec3i tpLimitedColor = new Vec3i((byte)205, (byte)169, (byte)205);
+  	Vec3i tpInvalidColor = new Vec3i((byte)83, (byte)83, (byte)83);
+    /** END MINECRIFT */
+    
     public EntityRenderer(Minecraft mcIn, IResourceManager resourceManagerIn)
     {
         this.shaderIndex = SHADER_COUNT;
@@ -198,6 +268,14 @@
                 this.rainYCoords[i << 5 | j] = f / f2;
             }
         }
+
+        //Vivecraft
+        if(mc.entityRenderer!=null){
+        	System.out.println("**********NEW ENTITY RENDERER ***********");
+        	java.lang.Thread.dumpStack();
+        }
+        //
+        
     }
 
     public void close()
@@ -378,21 +456,23 @@
             this.mc.renderGlobal.createBindEntityOutlineFbs(width, height);
         }
     }
-
+    
     /**
      * Gets the block or object that is being moused over.
      */
     public void getMouseOver(float partialTicks)
     {
-        Entity entity = this.mc.getRenderViewEntity();
+    	Entity entity = this.mc.getRenderViewEntity();
 
         if (entity != null && this.mc.world != null)
         {
             this.mc.profiler.startSection("pick");
             this.mc.pointedEntity = null;
             double d0 = (double)this.mc.playerController.getBlockReachDistance();
-            this.mc.objectMouseOver = entity.rayTrace(d0, partialTicks, RayTraceFluidMode.NEVER);
+            //Vivecraft override raytrace
+            this.mc.objectMouseOver = mc.vrPlayer.rayTraceMain(d0, RayTraceFluidMode.NEVER);
             Vec3d vec3d = entity.getEyePosition(partialTicks);
+            //TODO: Test how to handle vec3d for best server-side compatibility
             boolean flag = false;
             int i = 3;
             double d1 = d0;
@@ -631,17 +711,20 @@
     private void orientCamera(float partialTicks)
     {
         Entity entity = this.mc.getRenderViewEntity();
-        float f = this.renderEyeHeigsf + (this.renderEyeHeight - this.renderEyeHeigsf) * partialTicks;
-        double d0 = entity.prevPosX + (entity.posX - entity.prevPosX) * (double)partialTicks;
-        double d1 = entity.prevPosY + (entity.posY - entity.prevPosY) * (double)partialTicks + (double)entity.getEyeHeight();
-        double d2 = entity.prevPosZ + (entity.posZ - entity.prevPosZ) * (double)partialTicks;
-
-        if (entity instanceof EntityLivingBase && ((EntityLivingBase)entity).isPlayerSleeping())
+        //Vivecraft Override
+        float f = 0;
+        double d0 = rveX;
+        double d1 = rveY;
+        double d2 = rveZ;
+        //
+        
+        //Vivecraft never mess with camera for sleeping.
+        if ( !always_true && entity instanceof EntityLivingBase && ((EntityLivingBase)entity).isPlayerSleeping())
         {
             f = (float)((double)f + 1.0D);
             GlStateManager.translatef(0.0F, 0.3F, 0.0F);
 
-            if (!this.mc.gameSettings.debugCamEnable)
+            if (!this.mc.gameSettings.debugCamEnable) 
             {
                 BlockPos blockpos = new BlockPos(entity);
                 IBlockState iblockstate = this.mc.world.getBlockState(blockpos);
@@ -670,9 +753,12 @@
             }
             else
             {
-                float f1 = entity.rotationYaw;
-                float f2 = entity.rotationPitch;
-
+            	
+            	//Vivecraft Override
+                float f1 = rveyaw; //entity.rotationYaw;
+                float f2 = rvepitch; //entity.rotationPitch;
+                //
+                
                 if (this.mc.gameSettings.thirdPersonView == 2)
                 {
                     f2 += 180.0F;
@@ -747,15 +833,63 @@
         }
         else if (!this.mc.gameSettings.debugCamEnable)
         {
-            GlStateManager.rotatef(entity.getPitch(partialTicks), 1.0F, 0.0F, 0.0F);
-            GlStateManager.rotatef(entity.getYaw(partialTicks) + 180.0F, 0.0F, 1.0F, 0.0F);
+        	if(mc.currentPass == renderPass.Third){
+        		//mc.printGLMatrix("er");
+        		applyMRCameraRotation(false);		
+        	} else 	{
+        		// do proper 1st person camera orientation.
+        		GlStateManager.multMatrixf(mc.vrPlayer.vrdata_world_render.hmd.getMatrix().toFloatBuffer());
+        		//dont do depth here. Do later. cause reasons.
+        	}        
         }
-
         GlStateManager.translatef(0.0F, -f, 0.0F);
     }
 
-    public void setupCameraTransform(float partialTicks)
-    {
+
+    //do this separate to hide it from shadersmod shadow pass, also do the sky.
+    public void applyCameraDepth(boolean reverse){
+		if(mc.currentPass == renderPass.Third) return; //FUCK YOU stupid thing.
+			// Position
+			Vec3d campos =  mc.vrPlayer.vrdata_world_render.getEye(mc.currentPass).getPosition().subtract(mc.getRenderViewEntity().getPositionVector());
+			float x = (float) (campos.x );
+			float y = (float) (campos.y);
+			float z = (float) (campos.z );
+			int i = 1;
+			if(reverse) i = -1;
+			//This is just for depth.
+			GlStateManager.translatef(-x*i, -y*i, -z*i);	
+    }
+    
+    
+    public void setupCameraTransform(float partialTicks){
+    	this.setupCameraTransform(partialTicks, false);
+    }
+
+	public void setupClipPlanes()
+	{
+		this.farPlaneDistance = (float)(mc.gameSettings.renderDistanceChunks * 16);
+
+		if (Config.isFogFancy())
+		{
+			this.farPlaneDistance *= 0.95F;
+		}
+
+		if (Config.isFogFast())
+		{
+			this.farPlaneDistance *= 0.83F;
+		}
+
+		this.clipDistance = this.farPlaneDistance * 2.0F;
+
+        if (this.clipDistance < 173.0F)
+        {
+            this.clipDistance = 173.0F;
+        }    
+	}
+	
+    public void setupCameraTransform(float partialTicks, boolean isClouds)
+    { 	
+    	/* Vivecraft move to setupClipPlanes()
         this.farPlaneDistance = (float)(this.mc.gameSettings.renderDistanceChunks * 16);
 
         if (Config.isFogFancy())
@@ -767,32 +901,62 @@
         {
             this.farPlaneDistance *= 0.83F;
         }
-
-        GlStateManager.matrixMode(5889);
-        GlStateManager.loadIdentity();
+        
         this.clipDistance = this.farPlaneDistance * 2.0F;
-
+        
         if (this.clipDistance < 173.0F)
         {
             this.clipDistance = 173.0F;
         }
+    	*/	
 
-        if (this.cameraZoom != 1.0D)
-        {
-            GlStateManager.translatef((float)this.cameraYaw, (float)(-this.cameraPitch), 0.0F);
-            GlStateManager.scaled(this.cameraZoom, this.cameraZoom, 1.0D);
-        }
-
-        GlStateManager.multMatrixf(Matrix4f.perspective(this.getFOVModifier(partialTicks, true), (float)this.mc.mainWindow.getFramebufferWidth() / (float)this.mc.mainWindow.getFramebufferHeight(), 0.05F, this.clipDistance));
+        //Vivecraft no zoomies
+        //if (this.cameraZoom != 1.0D)
+        //{
+        //   GlStateManager.translatef((float)this.cameraYaw, (float)(-this.cameraPitch), 0.0F);
+        //    GlStateManager.scaled(this.cameraZoom, this.cameraZoom, 1.0D);
+        //}
+        
+        GlStateManager.matrixMode(5889);
+        GlStateManager.loadIdentity();
+        
+        //Vivecraft handle various projections
+		if (mc.currentPass == renderPass.Left || mc.currentPass == renderPass.Right)
+		{
+			int i = mc.currentPass.value();
+			if(i>1) i = 0;
+			if(isClouds){
+				GlStateManager.multMatrixf(mc.cloudeyeproj[i]);
+			}else{
+				GlStateManager.multMatrixf(mc.eyeproj[i]);
+			}
+		}
+		else
+		{
+			float clip = isClouds ? clipDistance * 4 : clipDistance;
+			if (mc.currentPass == renderPass.Third) {
+				GlStateManager.multMatrixf(Matrix4f.perspective(this.mc.vrSettings.mixedRealityFov, this.mc.vrSettings.mixedRealityAspectRatio , minClipDistance, clip));
+				GL11.glGetFloatv(GL11.GL_PROJECTION_MATRIX, matrixBuffer);
+				matrixBuffer.rewind();
+				this.thirdPassProjectionMatrix.read(matrixBuffer); //save it.
+				matrixBuffer.rewind();
+			} else {
+				GlStateManager.multMatrixf(Matrix4f.perspective(this.getFOVModifier(partialTicks, true), (float)this.mc.mainWindow.getFramebufferWidth() / (float)this.mc.mainWindow.getFramebufferHeight(), 0.05F, this.clipDistance));
+			}
+		}
+		//
         GlStateManager.matrixMode(5888);
         GlStateManager.loadIdentity();
+              
+        /* Vivecraft no hurties or bobs.
         this.hurtCameraEffect(partialTicks);
 
         if (this.mc.gameSettings.viewBobbing)
         {
             this.applyBobbing(partialTicks);
         }
-
+        */
+        
         float f = this.mc.player.prevTimeInPortal + (this.mc.player.timeInPortal - this.mc.player.prevTimeInPortal) * partialTicks;
 
         if (f > 0.0F)
@@ -818,10 +982,65 @@
     {
         this.renderHand(partialTicks, true, true, false);
     }
+    
+    public void renderHandVR_Main(float partialTicks)
+    {
+	
+		if(Config.isShaders()){
+			Shaders.beginHand(false);
+		}else {
+			GL11.glMatrixMode(GL11.GL_PROJECTION);
+			GL11.glPushMatrix();
+			GL11.glMatrixMode(GL11.GL_MODELVIEW);
+			GL11.glPushMatrix();
+		}	
+			//from player face to HMD
+			setupCameraTransform(partialTicks);
+			applyCameraDepth(false);
+			if (this.mc.gameSettings.thirdPersonView == 0) 
+			{
+				// VIVE START - from HMD to controller
+				SetupRenderingAtController(0);
+
+				ItemStack item = mc.player.getHeldItemMainhand();
+
+				if(mc.climbTracker.isClimbeyClimb() && (item.getItem() != Items.SHEARS)){
+					itemRenderer.renderItemInFirstPerson(mc.player, partialTicks, 0, EnumHand.MAIN_HAND, mc.player.getSwingProgress(partialTicks), mc.player.getHeldItemOffhand(), 0);				
+				}
+
+				if(BowTracker.isHoldingBow(mc.player, EnumHand.MAIN_HAND)){
+					//do ammo override
+					int c = 0;
+					if (mc.vrSettings.vrReverseShootingEye) c = 1;				
+					ItemStack ammo = mc.bowTracker.findAmmoItemStack(mc.player);
+					if (ammo !=null  && !mc.bowTracker.isNotched()) { //render the arrow in right, left hand will check for and render bow.
+						itemRenderer.renderItemInFirstPerson(mc.player, partialTicks, 0, EnumHand.MAIN_HAND, mc.player.getSwingProgress(partialTicks), ammo, 0);
+					} else {
+						itemRenderer.renderItemInFirstPerson(mc.player, partialTicks, 0, EnumHand.MAIN_HAND, mc.player.getSwingProgress(partialTicks), ItemStack.EMPTY, 0);
+					}
+				}
+				else if(BowTracker.isHoldingBow(mc.player, EnumHand.OFF_HAND) && mc.bowTracker.isNotched()){
+					int c = 0;
+					if (mc.vrSettings.vrReverseShootingEye) c = 1;				
+					itemRenderer.renderItemInFirstPerson(mc.player, partialTicks, 0, EnumHand.MAIN_HAND, mc.player.getSwingProgress(partialTicks), ItemStack.EMPTY, 0);
+				}else {
+					itemRenderer.renderItemInFirstPerson(mc.player, partialTicks, 0, EnumHand.MAIN_HAND, mc.player.getSwingProgress(partialTicks), item, 0);
+				}
+			}	
+		if(Config.isShaders())
+			Shaders.endHand();
+		else {
+			GL11.glMatrixMode(GL11.GL_PROJECTION);
+			GL11.glPopMatrix();
+			GL11.glMatrixMode(GL11.GL_MODELVIEW);
+			GL11.glPopMatrix();
+		}	
+	}
 
     public void renderHand(float p_renderHand_1_, boolean p_renderHand_2_, boolean p_renderHand_3_, boolean p_renderHand_4_)
     {
-        if (!this.debugView)
+    	//Vivecraft never. Use own method.
+        if (!this.debugView && !always_true)  
         {
             GlStateManager.matrixMode(5889);
             GlStateManager.loadIdentity();
@@ -916,19 +1135,22 @@
 
     public void updateCameraAndRender(float partialTicks, long nanoTime, boolean renderWorldIn)
     {
-        this.frameInit();
-
-        if (!this.mc.isGameFocused() && this.mc.gameSettings.pauseOnLostFocus && (!this.mc.gameSettings.touchscreen || !this.mc.mouseHelper.isRightDown()))
-        {
-            if (Util.milliTime() - this.prevFrameTime > 500L)
-            {
-                this.mc.displayInGameMenu();
-            }
-        }
-        else
-        {
-            this.prevFrameTime = Util.milliTime();
-        }
+    	
+    	if(mc.currentPass == renderPass.Left) { //Vivecraft once per pass
+    		this.frameInit();
+
+    		if (!always_true && !this.mc.isGameFocused() && this.mc.gameSettings.pauseOnLostFocus && (!this.mc.gameSettings.touchscreen || !this.mc.mouseHelper.isRightDown()))
+    		{//never pause on focus loss.
+    			if (Util.milliTime() - this.prevFrameTime > 500L)
+    			{
+    				this.mc.displayInGameMenu();
+    			}
+    		}
+    		else
+    		{
+    			this.prevFrameTime = Util.milliTime();
+    		}
+    	}
 
         if (!this.mc.skipRenderWorld)
         {
@@ -939,13 +1161,17 @@
             if (renderWorldIn && this.mc.world != null)
             {
                 this.mc.profiler.startSection("level");
+                
+                /* Vivecraft - never limit framerate, silly billy
                 int l = Math.min(Minecraft.getDebugFPS(), k);
                 l = Math.max(l, 60);
                 long i1 = Util.nanoTime() - nanoTime;
                 long j1 = Math.max((long)(1000000000 / l / 4) - i1, 0L);
-                this.renderWorld(partialTicks, Util.nanoTime() + j1);
+                */
+                
+                this.renderWorld(partialTicks, Long.MAX_VALUE);
 
-                if (this.mc.isSingleplayer() && this.timeWorldIcon < Util.milliTime() - 1000L)
+                if (mc.currentPass == renderPass.Third && this.mc.isSingleplayer() && this.timeWorldIcon < Util.milliTime() - 1000L)
                 {
                     this.timeWorldIcon = Util.milliTime();
 
@@ -971,10 +1197,11 @@
                     this.mc.getFramebuffer().bindFramebuffer(true);
                 }
 
-                this.mc.profiler.endStartSection("gui");
 
                 if (!this.mc.gameSettings.hideGUI || this.mc.currentScreen != null)
                 {
+                	/*
+                	this.mc.profiler.endStartSection("gui");
                     GlStateManager.alphaFunc(516, 0.1F);
                     this.mc.mainWindow.setupOverlayRendering();
                     this.renderItemActivation(this.mc.mainWindow.getScaledWidth(), this.mc.mainWindow.getScaledHeight(), partialTicks);
@@ -989,23 +1216,26 @@
                     {
                         Lagometer.showLagometer((int)this.mc.mainWindow.getGuiScaleFactor());
                     }
+                    */
                 }
 
                 this.mc.profiler.endSection();
             }
             else
             {
+            	/*
                 GlStateManager.viewport(0, 0, this.mc.mainWindow.getFramebufferWidth(), this.mc.mainWindow.getFramebufferHeight());
                 GlStateManager.matrixMode(5889);
                 GlStateManager.loadIdentity();
                 GlStateManager.matrixMode(5888);
                 GlStateManager.loadIdentity();
                 this.mc.mainWindow.setupOverlayRendering();
+                */
                 TileEntityRendererDispatcher.instance.textureManager = this.mc.getTextureManager();
                 TileEntityRendererDispatcher.instance.fontRenderer = this.mc.fontRenderer;
             }
 
-            if (this.mc.currentScreen != null)
+            if (!always_true && this.mc.currentScreen != null)
             {
                 GlStateManager.clear(256);
 
@@ -1040,6 +1270,31 @@
                 }
             }
         }
+        
+    	GlStateManager.disableBlend();
+    	GlStateManager.disableAlphaTest();
+    	GlStateManager.enableDepthTest();
+    	GlStateManager.enableTexture2D();
+
+    	if (this.mc.world == null || mc.currentScreen instanceof GuiWinGame) {
+    		this.mc.profiler.startSection("renderGui");
+    		GL11.glDisable(GL11.GL_STENCIL_TEST);
+
+    		renderGuiLayer(partialTicks);
+    		if(KeyboardHandler.Showing)
+    			render2D(partialTicks, KeyboardHandler.Framebuffer, KeyboardHandler.Pos_room, KeyboardHandler.Rotation_room);
+
+    		if( mc.currentPass != renderPass.Third || mc.vrSettings.mixedRealityRenderHands){
+    			// VIVE START - render controllers in main menu
+    			this.mc.profiler.startSection("mainMenuHands");
+    			renderMainMenuHands();
+    			this.mc.profiler.endSection();
+    		}
+
+    		this.mc.profiler.endSection();
+    	}
+
+    	handleNotificationText();
 
         this.frameFinish();
         this.waitForServerThread();
@@ -1125,63 +1380,86 @@
 
     private boolean isDrawBlockOutline()
     {
-        if (!this.drawBlockOutline)
-        {
-            return false;
-        }
-        else
-        {
-            Entity entity = this.mc.getRenderViewEntity();
-            boolean flag = entity instanceof EntityPlayer && !this.mc.gameSettings.hideGUI;
-
-            if (flag && !((EntityPlayer)entity).capabilities.allowEdit)
-            {
-                ItemStack itemstack = ((EntityPlayer)entity).getHeldItemMainhand();
+    	if (!this.drawBlockOutline || 
+    			(mc.gameSettings.hideGUI && mc.vrSettings.renderBlockOutlineMode == VRSettings.RENDER_BLOCK_OUTLINE_MODE_HUD) ||
+    			mc.vrSettings.renderBlockOutlineMode == VRSettings.RENDER_BLOCK_OUTLINE_MODE_NEVER ||
+    			mc.teleportTracker.isAiming())
+    	{
+    		return false;
+    	}
+    	else
+    	{
+    		Entity entity = this.mc.getRenderViewEntity();
+    		boolean flag = entity instanceof EntityPlayer && !this.mc.gameSettings.hideGUI;
+
+    		if (flag && !((EntityPlayer)entity).capabilities.allowEdit)
+    		{
+    			ItemStack itemstack = ((EntityPlayer)entity).getHeldItemMainhand();
+
+    			if (this.mc.objectMouseOver != null && this.mc.objectMouseOver.type == RayTraceResult.Type.BLOCK)
+    			{
+    				BlockPos blockpos = this.mc.objectMouseOver.getBlockPos();
+    				IBlockState iblockstate = this.mc.world.getBlockState(blockpos);
+    				Block block = iblockstate.getBlock();
+
+    				if (this.mc.playerController.getCurrentGameType() == GameType.SPECTATOR)
+    				{
+    					flag = ReflectorForge.blockHasTileEntity(iblockstate) && this.mc.world.getTileEntity(blockpos) instanceof IInventory;
+    				}
+    				else
+    				{
+    					BlockWorldState blockworldstate = new BlockWorldState(this.mc.world, blockpos, false);
+    					flag = !itemstack.isEmpty() && (itemstack.canDestroy(this.mc.world.getTags(), blockworldstate) || itemstack.canPlaceOn(this.mc.world.getTags(), blockworldstate));
+    				}
+    			}
+    		}
 
-                if (this.mc.objectMouseOver != null && this.mc.objectMouseOver.type == RayTraceResult.Type.BLOCK)
-                {
-                    BlockPos blockpos = this.mc.objectMouseOver.getBlockPos();
-                    IBlockState iblockstate = this.mc.world.getBlockState(blockpos);
-                    Block block = iblockstate.getBlock();
-
-                    if (this.mc.playerController.getCurrentGameType() == GameType.SPECTATOR)
-                    {
-                        flag = ReflectorForge.blockHasTileEntity(iblockstate) && this.mc.world.getTileEntity(blockpos) instanceof IInventory;
-                    }
-                    else
-                    {
-                        BlockWorldState blockworldstate = new BlockWorldState(this.mc.world, blockpos, false);
-                        flag = !itemstack.isEmpty() && (itemstack.canDestroy(this.mc.world.getTags(), blockworldstate) || itemstack.canPlaceOn(this.mc.world.getTags(), blockworldstate));
-                    }
-                }
-            }
-
-            return flag;
-        }
+    		return flag;
+    	}
     }
 
     public void renderWorld(float partialTicks, long finishTimeNano)
     {
-        this.lightmapTexture.updateLightmap(partialTicks);
+    	if(mc.currentPass == renderPass.Left)
+    		this.lightmapTexture.updateLightmap(partialTicks);
 
-        if (this.mc.getRenderViewEntity() == null)
-        {
-            this.mc.setRenderViewEntity(this.mc.player);
-        }
-
-        this.getMouseOver(partialTicks);
-
-        if (Config.isShaders())
-        {
-            Shaders.beginRender(this.mc, partialTicks, finishTimeNano);
-        }
-
-        GlStateManager.enableDepthTest();
-        GlStateManager.enableAlphaTest();
-        GlStateManager.alphaFunc(516, 0.1F);
-        this.mc.profiler.startSection("center");
-        this.updateCameraAndRender(partialTicks, finishTimeNano);
-        this.mc.profiler.endSection();
+    	if (this.mc.getRenderViewEntity() == null)
+    	{
+    		this.mc.setRenderViewEntity(this.mc.player);
+    	}
+
+    	//Vivecraft
+    	cacheRVEPos((EntityLivingBase) mc.getRenderViewEntity());	
+    	setupRVE();
+     	if(mc.currentPass == renderPass.Left)
+    	//
+    		this.getMouseOver(partialTicks);
+
+    	if(this.mc.currentScreen == null)
+    	{
+    		// Set up crosshair position
+    		float SLIGHTLY_CLOSER = -0.1f;
+    		Vec3d eye = mc.vrPlayer.vrdata_world_render.getEye(mc.currentPass).getPosition();
+    		Vec3d pos = mc.vrPlayer.vrdata_world_render.hmd.getPosition();
+    		Vec3d centerEyePosToCrossDirection = eye.subtract(crossVec).normalize();   // VIVE use camerapos
+    		crossX = (float)(crossVec.x - (centerEyePosToCrossDirection.x*SLIGHTLY_CLOSER) -  pos.x);
+    		crossY = (float)(crossVec.y - (centerEyePosToCrossDirection.y*SLIGHTLY_CLOSER) -  pos.y);
+    		crossZ = (float)(crossVec.z - (centerEyePosToCrossDirection.z*SLIGHTLY_CLOSER) -  pos.z);
+    		// information for the entire frame, not individual eye pos camRelX, Y, Z
+    	}
+    	//
+
+    	if (Config.isShaders())
+    	{
+    		Shaders.beginRender(this.mc, partialTicks, finishTimeNano);
+    	}
+
+    	GlStateManager.enableDepthTest();
+    	GlStateManager.enableAlphaTest();
+    	GlStateManager.alphaFunc(516, 0.1F);
+    	this.mc.profiler.startSection("center");
+    	this.updateCameraAndRender(partialTicks, finishTimeNano);
+    	this.mc.profiler.endSection();
     }
 
     private void updateCameraAndRender(float partialTicks, long nanoTime)
@@ -1197,6 +1475,7 @@
         ParticleManager particlemanager = this.mc.effectRenderer;
         boolean flag1 = this.isDrawBlockOutline();
         GlStateManager.enableCull();
+        
         this.mc.profiler.endStartSection("clear");
 
         if (flag)
@@ -1216,9 +1495,27 @@
             Shaders.clearRenderBuffer();
         }
 
+        //Vivecraft - VR Stencil
+    	this.mc.profiler.endStartSection("stencil");
+			if(mc.currentPass != renderPass.Third && mc.currentPass != renderPass.Center && mc.vrSettings.vrUseStencil && MCOpenVR.isHMDTracking()){
+				if(flag){
+					GL30.glBindFramebuffer(GL30.GL_FRAMEBUFFER, Shaders.dfb);
+					Shaders.useProgram(Shaders.ProgramNone);
+				}
+				mc.doStencilForEye(mc.currentPass == renderPass.Left? 0 : 1); //TODO: dont render this every damn frame.				
+			}
+			else{
+				GL11.glDisable(GL11.GL_STENCIL_TEST);
+			}
+		//
+	        
         this.mc.profiler.endStartSection("camera");
         this.setupCameraTransform(partialTicks);
 
+        //Vivecraft
+        applyCameraDepth(false); 
+        //
+        
         if (flag)
         {
             Shaders.setCamera(partialTicks);
@@ -1257,8 +1554,12 @@
             this.fogRenderer.setupFog(-1, partialTicks);
             this.mc.profiler.endStartSection("sky");
             GlStateManager.matrixMode(5889);
-            GlStateManager.loadIdentity();
-            GlStateManager.multMatrixf(Matrix4f.perspective(this.getFOVModifier(partialTicks, true), (float)this.mc.mainWindow.getFramebufferWidth() / (float)this.mc.mainWindow.getFramebufferHeight(), 0.05F, this.clipDistance));
+            //Vivecraft - no fov shenanigans
+            GlStateManager.pushMatrix();
+            //GlStateManager.matrixMode(5889);
+            //GlStateManager.loadIdentity();
+            //GlStateManager.multMatrixf(Matrix4f.perspective(this.getFOVModifier(partialTicks, true), (float)this.mc.mainWindow.getFramebufferWidth() / (float)this.mc.mainWindow.getFramebufferHeight(), 0.05F, this.clipDistance));
+            //
             GlStateManager.matrixMode(5888);
 
             if (flag)
@@ -1274,8 +1575,11 @@
             }
 
             GlStateManager.matrixMode(5889);
-            GlStateManager.loadIdentity();
-            GlStateManager.multMatrixf(Matrix4f.perspective(this.getFOVModifier(partialTicks, true), (float)this.mc.mainWindow.getFramebufferWidth() / (float)this.mc.mainWindow.getFramebufferHeight(), 0.05F, this.clipDistance));
+            //Vivecraft no FOV shenanigans pt 2
+            GlStateManager.popMatrix();
+            //GlStateManager.loadIdentity();
+            //GlStateManager.multMatrixf(Matrix4f.perspective(this.getFOVModifier(partialTicks, true), (float)this.mc.mainWindow.getFramebufferWidth() / (float)this.mc.mainWindow.getFramebufferHeight(), 0.05F, this.clipDistance));
+            //
             GlStateManager.matrixMode(5888);
         }
         else
@@ -1306,15 +1610,17 @@
         {
             renderglobal.setupTerrain(entity, partialTicks, icamera, this.frameCount++, this.mc.player.isSpectator());
         }
-
-        this.mc.profiler.endStartSection("updatechunks");
-        Lagometer.timerChunkUpload.start();
-        this.mc.renderGlobal.updateChunks(nanoTime);
-        Lagometer.timerChunkUpload.end();
-        this.mc.profiler.endStartSection("terrain");
-        Lagometer.timerTerrain.start();
-
-        if (this.mc.gameSettings.ofSmoothFps)
+        
+        if(mc.currentPass == renderPass.Left) {//Vivecraft do once.
+        	this.mc.profiler.endStartSection("updatechunks");
+        	Lagometer.timerChunkUpload.start();
+        	this.mc.renderGlobal.updateChunks(nanoTime);
+        	Lagometer.timerChunkUpload.end();
+        	this.mc.profiler.endStartSection("terrain");
+        	Lagometer.timerTerrain.start();
+        }
+        
+        if (!always_true && this.mc.gameSettings.ofSmoothFps) //never!
         {
             this.mc.profiler.endStartSection("finish");
             GL11.glFinish();
@@ -1417,12 +1723,63 @@
 
         GlStateManager.blendFuncSeparate(770, 771, 1, 0);
         GlStateManager.disableBlend();
-        this.enableLightmap();
+
+        this.mc.profiler.endStartSection("VR");
+	
+	        if(flag)
+	        	Shaders.useProgram(Shaders.ProgramEntities); //entities
+	
+	        renderCrosshairAtDepth();
+	
+	        if(flag)
+	        	Shaders.useProgram(Shaders.ProgramEntities); //entities
+	
+	        renderGuiLayer(partialTicks);  
+	        if(KeyboardHandler.Showing)
+	        	render2D(partialTicks, KeyboardHandler.Framebuffer, KeyboardHandler.Pos_room, KeyboardHandler.Rotation_room);
+	        if(RadialHandler.Showing)
+	        	render2D(partialTicks, RadialHandler.Framebuffer, RadialHandler.Pos_room, RadialHandler.Rotation_room);
+	
+	        if(flag){
+	        	GlStateManager.enableLighting();
+	        	GlStateManager.colorMask(true, true, true, true);
+	        }
+	
+	        if (mc.currentPass != renderPass.Third || mc.vrSettings.displayMirrorMode != VRSettings.MIRROR_THIRD_PERSON) 
+	        {
+	        	this.renderVRThings(partialTicks);
+	        }
+	
+
+        this.mc.profiler.endStartSection("vr hands");
+    	this.enableLightmap();
+    	
+        boolean forgeHands = false;
+
+        if(!Main.viewonly && (mc.currentPass != renderPass.Third || mc.vrSettings.displayMirrorMode != VRSettings.MIRROR_THIRD_PERSON)) 
+        {
+	    	RenderHelper.enableStandardItemLighting();
+	    	itemRenderer.setLightmap();
+	    	GlStateManager.enableRescaleNormal();
+
+	    	this.renderHandVR_Main(partialTicks);
+	    	this.renderHandVR_Offhand(partialTicks);
+	    	//			
+	    	forgeHands = ReflectorForge.renderFirstPersonHand(this.mc.renderGlobal, partialTicks, pass);
+	    	//		        
+	    	GlStateManager.disableRescaleNormal();
+	    	RenderHelper.disableStandardItemLighting();
+	    	GlStateManager.enableTexture2D();	
+	    }
+
+        GlStateManager.matrixMode(GL11.GL_MODELVIEW);
+        GlStateManager.popMatrix();
+  
         this.mc.profiler.endStartSection("litParticles");
 
         if (flag)
         {
-            Shaders.beginLitParticles();
+        	Shaders.beginLitParticles();
         }
 
         particlemanager.renderLitParticles(entity, partialTicks);
@@ -1432,14 +1789,14 @@
 
         if (flag)
         {
-            Shaders.beginParticles();
+        	Shaders.beginParticles();
         }
 
         particlemanager.renderParticles(entity, partialTicks);
 
         if (flag)
         {
-            Shaders.endParticles();
+        	Shaders.endParticles();
         }
 
         this.disableLightmap();
@@ -1447,7 +1804,7 @@
 
         if (Config.isShaders())
         {
-            GlStateManager.depthMask(Shaders.isRainDepth());
+        	GlStateManager.depthMask(Shaders.isRainDepth());
         }
 
         GlStateManager.enableCull();
@@ -1470,7 +1827,8 @@
 
         if (flag)
         {
-            ShadersRender.renderHand0(this, partialTicks);
+        	//Vivecraft Nope
+            //ShadersRender.renderHand0(this, partialTicks);
             Shaders.preWater();
         }
 
@@ -1526,11 +1884,24 @@
             Reflector.callVoid(Reflector.ForgeHooksClient_dispatchRenderLast, renderglobal, partialTicks);
         }
 
+        if (mc.currentPass != renderPass.Third) //no fp overlay for 3rd cam.
+        {
+        	this.renderFaceOverlay(partialTicks);
+        }
+
+        this.mc.profiler.endStartSection("ShadersEnd");
+        if ( flag && !forgeHands && this.renderHand && !Shaders.isShadowPass)
+        {
+        	GL11.glDisable(GL11.GL_STENCIL_TEST);
+        	Shaders.renderCompositeFinal();
+        }
+
+        /*Nope
         this.mc.profiler.endStartSection("hand");
 
         if (this.renderHand && !Shaders.isShadowPass)
         {
-            if (flag)
+        	if (flag)
             {
                 ShadersRender.renderHand1(this, partialTicks);
                 Shaders.renderCompositeFinal();
@@ -1547,11 +1918,17 @@
                 this.renderHand(partialTicks);
             }
         }
-
+         */
+        
         if (flag)
         {
+        	GL11.glDisable(GL11.GL_STENCIL_TEST);
+        	Shaders.renderCompositeFinal();
             Shaders.endRender();
         }
+        
+        restoreRVEPos((EntityLivingBase) mc.getRenderViewEntity()); //unhack the RVE position.
+
     }
 
     private void renderCloudsCheck(RenderGlobal renderGlobalIn, float partialTicks, double viewEntityX, double viewEntityY, double viewEntityZ)
@@ -1561,7 +1938,11 @@
             this.mc.profiler.endStartSection("clouds");
             GlStateManager.matrixMode(5889);
             GlStateManager.loadIdentity();
-            GlStateManager.multMatrixf(Matrix4f.perspective(this.getFOVModifier(partialTicks, true), (float)this.mc.mainWindow.getFramebufferWidth() / (float)this.mc.mainWindow.getFramebufferHeight(), 0.05F, this.clipDistance * 4.0F));
+        	//VIVE - no fov shenanigans pt 2 pt 2
+        	this.setupCameraTransform(partialTicks, true);
+        	applyCameraDepth(false);
+            //GlStateManager.multMatrixf(Matrix4f.perspective(this.getFOVModifier(partialTicks, true), (float)this.mc.mainWindow.getFramebufferWidth() / (float)this.mc.mainWindow.getFramebufferHeight(), 0.05F, this.clipDistance * 4.0F));
+        	//
             GlStateManager.matrixMode(5888);
             GlStateManager.pushMatrix();
             this.fogRenderer.setupFog(0, partialTicks);
@@ -1570,7 +1951,11 @@
             GlStateManager.popMatrix();
             GlStateManager.matrixMode(5889);
             GlStateManager.loadIdentity();
-            GlStateManager.multMatrixf(Matrix4f.perspective(this.getFOVModifier(partialTicks, true), (float)this.mc.mainWindow.getFramebufferWidth() / (float)this.mc.mainWindow.getFramebufferHeight(), 0.05F, this.clipDistance));
+        	//VIVE - no fov shenanigans pt 2 pt 3
+        	this.setupCameraTransform(partialTicks, false);
+        	applyCameraDepth(false);
+            //GlStateManager.multMatrixf(Matrix4f.perspective(this.getFOVModifier(partialTicks, true), (float)this.mc.mainWindow.getFramebufferWidth() / (float)this.mc.mainWindow.getFramebufferHeight(), 0.05F, this.clipDistance));
+            //
             GlStateManager.matrixMode(5888);
         }
     }
@@ -2002,7 +2387,7 @@
             this.updatedWorld = world;
         }
 
-        if (!this.setFxaaShader(Shaders.configAntialiasingLevel))
+        if (!this.setFxaaShader(Shaders.configAntialiasingLevel)) //Vivecraft no AA, sorry.
         {
             Shaders.configAntialiasingLevel = 0;
         }
@@ -2288,4 +2673,1983 @@
     {
         return this.farPlaneDistance;
     }
+  //VIVECRAFT ADDITIONS *********************************************************
+
+  	private float checkCameraCollision(
+  			double camX,       double camY,       double camZ,
+  			double camXOffset, double camYOffset, double camZOffset, float distance )
+  	{
+  		//This loop offsets at [-.1, -.1, -.1], [.1,-.1,-.1], [.1,.1,-.1] etc... for all 8 directions
+  		double minDistance = -1d;
+
+  		// Lets extend out the test range somewhat
+  		camXOffset *= 10f;
+  		camYOffset *= 10f;
+  		camZOffset *= 10f;
+
+  		for (int var20 = 0; var20 < 8; ++var20)
+  		{
+  			final float MIN_DISTANCE = 0.06F;
+  			float var21 = (float)((var20 & 1) * 2 - 1);
+  			float var22 = (float)((var20 >> 1 & 1) * 2 - 1);
+  			float var23 = (float)((var20 >> 2 & 1) * 2 - 1);
+  			var21 *= 0.1F;
+  			var22 *= 0.1F;
+  			var23 *= 0.1F;
+  			RayTraceResult var24 = this.mc.world.rayTraceBlocks(
+  					new Vec3d(camX + var21, camY + var22, camZ + var23),
+  					new Vec3d(camX - camXOffset + var21, camY - camYOffset + var22, camZ - camZOffset + var23));
+
+  			BlockPos bp = var24.getBlockPos();
+  			if (var24 != null && this.mc.world.isBlockNormalCube(bp, true))
+  			{
+  				double var25 = var24.hitVec.distanceTo(new Vec3d(camX, camY, camZ)) - MIN_DISTANCE;
+
+  				if (minDistance == -1d)
+  				{
+  					minDistance = var25;
+  				}
+  				else if (var25 < minDistance)
+  				{
+  					minDistance = var25;
+  				}
+  			}
+  		}
+  		if (minDistance == -1d)
+  			minDistance = distance *= 10d;
+
+  		return (float)minDistance;
+  	}
+
+  	public void drawSizedQuad(float displayWidth, float displayHeight, float size)
+  	{
+  		float aspect = displayHeight / displayWidth;
+
+  		GL11.glBegin(GL11.GL_QUADS);
+
+  		GL11.glNormal3f(0, 0, 1);
+  		GL11.glTexCoord2f(0.0f, 0.0f);
+  		GL11.glVertex3f(-(size / 2f), -(size * aspect) / 2f, 0.0f);  // Bottom Left Of The Texture and Quad
+  		GL11.glTexCoord2f(1.0f, 0.0f);
+  		GL11.glVertex3f(size / 2f, -(size * aspect) / 2f, 0.0f);  // Bottom Right Of The Texture and Quad
+  		GL11.glTexCoord2f(1.0f, 1.0f);
+  		GL11.glVertex3f(size / 2f, (size * aspect) / 2f, 0.0f);  // Top Right Of The Texture and Quad
+  		GL11.glTexCoord2f(0.0f, 1.0f);
+  		GL11.glVertex3f(-(size / 2f), (size * aspect) / 2f, 0.0f);  // Top Left  Of The Texture and Quad
+
+  		GL11.glEnd();
+  	}
+
+  	public void handleNotificationText()
+  	{
+  		String prefix = "";
+  		String message = "";
+  		String suffix = "";
+
+  		boolean renderTxt = false;
+
+  		// error info takes precedence
+  		if (mc.errorHelper != null) {
+  			if (System.currentTimeMillis() < mc.errorHelper.endTime)
+  			{
+  				prefix = mc.errorHelper.title;
+  				message = mc.errorHelper.message;
+  				suffix = mc.errorHelper.resolution;
+  				renderTxt = true;
+  			}
+  			else
+  			{
+  				mc.errorHelper = null;
+  			}
+  		}
+  		// otherwise display any calibration info
+  		if (renderTxt)
+  			displayNotificationText(prefix, message, suffix,
+  					this.mc.displayWidth, this.mc.displayHeight, true, !false);
+  	}
+
+  	// Thanks to mhagain
+  	public void renderFadeBlend (float r, float g, float b, float fadeAlpha, int left, int right, int bottom, int top)
+  	{
+  		if(fadeAlpha == 0 || Config.isShaders()) return;
+  		//TODO: fix under shadersmod
+  		
+  		GlStateManager.enableBlend();
+  		GlStateManager.disableAlphaTest();
+  		GlStateManager.blendFuncSeparate(SourceFactor.SRC_ALPHA, DestFactor.ONE_MINUS_SRC_ALPHA,SourceFactor.SRC_ALPHA, DestFactor.ONE_MINUS_SRC_ALPHA);
+  		GlStateManager.disableDepthTest();
+  		GlStateManager.disableTexture2D();
+  		GlStateManager.disableLighting();
+  		
+  		GL11.glMatrixMode(GL11.GL_PROJECTION);
+  		GL11.glPushMatrix();
+  		GL11.glLoadIdentity();
+
+  		// when laying out a 2D view, sometimes "top-left is the origin" makes more sense.
+  		// it is the direction i read in, after all.  live with it, weenies.
+  		GL11.glOrtho(0, this.mc.displayFBWidth, this.mc.displayFBHeight, 0, -1, 1);
+
+  		GL11.glMatrixMode(GL11.GL_MODELVIEW);
+  		GL11.glPushMatrix();
+  			GL11.glLoadIdentity();
+  	
+  			GlStateManager.color4f(r, g, b, fadeAlpha);
+  	
+  			GL11.glBegin(GL11.GL_QUADS);
+  	
+  			GL11.glVertex3f(left, top, 0);
+  			GL11.glVertex3f(left, bottom, 0);
+  			GL11.glVertex3f(right, bottom, 0);
+  			GL11.glVertex3f(right, top, 0);
+
+  			GL11.glEnd();
+  	
+  			GL11.glMatrixMode(GL11.GL_PROJECTION);
+  			GL11.glPopMatrix();
+  	
+  			GL11.glMatrixMode(GL11.GL_MODELVIEW);
+  		GL11.glPopMatrix();
+  		
+  		GlStateManager.enableDepthTest();
+  		GlStateManager.enableTexture2D();
+  		GlStateManager.enableAlphaTest();
+  		GlStateManager.enableLighting();
+  		
+  	}
+
+  	/** Renders the pre-generated 2-d framebuffer into the world at the appropriate location..
+  	 * @param par1
+  	 */
+  	void render2D(float par1, Framebuffer framebuffer, Vec3d pos, Matrix4f rot)
+  	{
+
+      	if(mc.bowTracker.isDrawing) return;	
+      	    	
+  			boolean inMenuRoom = this.mc.world == null || mc.currentScreen instanceof GuiWinGame || mc.integratedServerLaunchInProgress ;
+  			// Pass matrici on to OpenGL...
+  			GL11.glMatrixMode(GL11.GL_PROJECTION);
+  			GL11.glLoadIdentity();
+  			
+  			// Minecrift - use correct projection
+  			if (mc.currentPass == renderPass.Left || mc.currentPass ==renderPass.Right)
+  			{			
+  				int i = mc.currentPass.value();
+  				if(i > 1) i = 0;
+  				GL11.glMultMatrixf(mc.cloudeyeproj[i]);
+  			}
+  			else if (mc.currentPass == renderPass.Third) {
+  				Project.gluPerspective(this.mc.vrSettings.mixedRealityFov, this.mc.vrSettings.mixedRealityAspectRatio, minClipDistance, clipDistance * 4);
+  			} else {
+  				Project.gluPerspective(this.mc.gameSettings.fovSetting, (float)this.mc.displayWidth / (float) this.mc.displayHeight, minClipDistance, clipDistance * 4);
+  			}
+  		
+  			
+  			if (mc.currentPass == renderPass.Third && this.mc.world == null) {
+  				matrixBuffer.rewind();
+  				GL11.glGetFloatv(GL11.GL_PROJECTION_MATRIX, matrixBuffer);
+  				matrixBuffer.rewind();
+  				this.thirdPassProjectionMatrix.read(matrixBuffer);
+  				matrixBuffer.rewind();
+  			}
+  	
+  			GL11.glMatrixMode(GL11.GL_MODELVIEW);
+  			GL11.glLoadIdentity();
+  			// VIVE START - custom GUI position
+  			GL11.glPushMatrix();
+  				applyMenuRoomModelView(this.mc.currentPass);
+  						
+  					GlStateManager.loadIdentity();
+  					apply2DModelView(this.mc.currentPass, pos, rot);
+  					
+  					framebuffer.bindFramebufferTexture();
+
+  					GlStateManager.disableCull();
+  					GlStateManager.enableTexture2D();
+  					
+  					// Prevent black border at top / bottom of GUI
+  					GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL12.GL_CLAMP_TO_EDGE);
+  					GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL12.GL_CLAMP_TO_EDGE);
+
+  					// Set texture filtering
+  					GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR_MIPMAP_LINEAR);
+  					GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_LINEAR);
+  					GL11.glTexParameterf(GL11.GL_TEXTURE_2D, EXTTextureFilterAnisotropic.GL_TEXTURE_MAX_ANISOTROPY_EXT, 16.0f);
+
+  					if (!inMenuRoom)
+  					{
+  						GlStateManager.enableBlend();
+  						GL14.glBlendColor(1, 1, 1, mc.vrSettings.hudOpacity);
+  						if(Minecraft.getMinecraft().player != null && Minecraft.getMinecraft().player.isSneaking()){
+  							GL14.glBlendColor(1, 1, 1, mc.vrSettings.hudOpacity * 0.75f);
+  						}
+  						GlStateManager.blendFunc(SourceFactor.CONSTANT_ALPHA, DestFactor.ONE_MINUS_CONSTANT_ALPHA);
+  					}
+  					else{
+  						GlStateManager.disableBlend();
+  						GlStateManager.color4f(1, 1, 1, 1f);
+  						GL14.glBlendColor(1, 1, 1, 1);
+  					}
+
+  			        Vec3d poseye = mc.vrPlayer.vrdata_world_render.getEye(mc.currentPass).getPosition();
+  		        
+  					if (inMenuRoom || mc.currentScreen != null ||
+  							!this.mc.vrSettings.hudOcclusion 
+  							|| itemRenderer.isInsideOpaqueBlock(poseye, false)){
+  						GlStateManager.depthFunc(GL11.GL_ALWAYS);
+  					} else {				
+  						GlStateManager.depthFunc(GL11.GL_LEQUAL);
+  					}
+  					
+  					if(mc.currentPass == renderPass.Third){
+  						GlStateManager.depthFunc(GL11.GL_LEQUAL);					}
+  					
+  					//the framebuffer has to be drawn with color blending transparency to support non-alpha cursors. Always has a black background.	
+                      GlStateManager.alphaFunc(GL11.GL_GREATER, 0.01f);
+  					GlStateManager.depthMask(true);
+  					GlStateManager.enableDepthTest();
+
+  					//Render framebuffer onto world projection
+  					ScaledResolution s = new ScaledResolution(mc);
+  							
+  					if(inMenuRoom)
+  						GlStateManager.disableAlphaTest();
+  					else
+  						GlStateManager.enableAlphaTest();
+  					
+  					GlStateManager.disableLighting();		
+  					
+  					drawSizedQuad(s.getScaledWidth(), s.getScaledHeight(), 1.5f); 
+
+  					GL14.glBlendColor(1, 1, 1, 1);
+  					GlStateManager.blendFunc(SourceFactor.SRC_ALPHA, DestFactor.ONE_MINUS_SRC_ALPHA);
+  					GlStateManager.enableDepthTest();
+  					GlStateManager.depthFunc(GL11.GL_LEQUAL);
+  					GlStateManager.enableCull();
+
+  	
+  			GL11.glMatrixMode(GL11.GL_MODELVIEW);
+  			GL11.glPopMatrix();			
+  }
+
+
+  	/** Renders the pre-generated 2-d framebuffer into the world at the appropriate location..
+  	 * @param par1
+  	 */
+  	void renderGuiLayer(float par1)
+  	{
+      	if(mc.bowTracker.isDrawing) return;	
+      	
+      	if(mc.currentScreen ==null && mc.gameSettings.hideGUI) return;
+      	
+  			boolean inMenuRoom = this.mc.world == null || mc.currentScreen instanceof GuiWinGame || mc.integratedServerLaunchInProgress ;
+  			// Pass matrici on to OpenGL...
+  			GL11.glMatrixMode(GL11.GL_PROJECTION);
+  			GL11.glLoadIdentity();
+  			
+  			// Minecrift - use correct projection
+  			if (mc.currentPass == renderPass.Left || mc.currentPass ==renderPass.Right)
+  			{			
+  				int i = mc.currentPass.value();
+  				if(i > 1) i = 0;
+  				GL11.glMultMatrixf(mc.cloudeyeproj[i]);
+  			}
+  			else if (mc.currentPass == renderPass.Third) {
+  				Project.gluPerspective(this.mc.vrSettings.mixedRealityFov, this.mc.vrSettings.mixedRealityAspectRatio, minClipDistance, clipDistance * 4);
+  			} else {
+  				Project.gluPerspective(this.mc.gameSettings.fovSetting, (float)this.mc.displayWidth / (float) this.mc.displayHeight, minClipDistance, clipDistance * 4);
+  			}
+  		
+  			
+  			if (mc.currentPass == renderPass.Third && this.mc.world == null) {
+  				matrixBuffer.rewind();
+  				GL11.glGetFloat(GL11.GL_PROJECTION_MATRIX, matrixBuffer);
+  				matrixBuffer.rewind();
+  				this.thirdPassProjectionMatrix.read(matrixBuffer);
+  				matrixBuffer.rewind();
+  			}
+  	
+  			GL11.glMatrixMode(GL11.GL_MODELVIEW);
+  			GL11.glLoadIdentity();
+  			// VIVE START - custom GUI position
+  			GL11.glPushMatrix();
+  				applyMenuRoomModelView(this.mc.currentPass);
+  	
+  					///MAIN MENU ENVIRONMENT            
+  					if(inMenuRoom){		
+  						if (mc.menuWorldRenderer != null && mc.menuWorldRenderer.isReady()) {
+  							renderTechjarsAwesomeMainMenuRoom();
+  						} else {
+  							renderJrbuddasAwesomeMainMenuRoom();
+  						}
+  					}
+  					//END AWESOME MAIN MENU ENVIRONMENT
+  					
+  					GlStateManager.loadIdentity();
+  					applyGUIModelView(this.mc.currentPass);
+  					
+  					GuiHandler.guiFramebuffer.bindFramebufferTexture();
+
+  					GlStateManager.disableCull();
+  				//	RenderHelper.disableStandardItemLighting();    
+  					GlStateManager.enableTexture2D();
+  					
+  					// Prevent black border at top / bottom of GUI
+  					GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL12.GL_CLAMP_TO_EDGE);
+  					GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL12.GL_CLAMP_TO_EDGE);
+
+  					// Set texture filtering
+  					GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR_MIPMAP_LINEAR);
+  					GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_LINEAR);
+  					GL11.glTexParameterf(GL11.GL_TEXTURE_2D, EXTTextureFilterAnisotropic.GL_TEXTURE_MAX_ANISOTROPY_EXT, 16.0f);
+
+  					if (!inMenuRoom)
+  					{
+  						GlStateManager.enableBlend();
+  						GL14.glBlendColor(1, 1, 1, mc.vrSettings.hudOpacity);
+  						if(Minecraft.getMinecraft().player != null && Minecraft.getMinecraft().player.isSneaking()){
+  							GL14.glBlendColor(1, 1, 1, mc.vrSettings.hudOpacity * 0.75f);
+  						}
+  						GlStateManager.blendFunc(SourceFactor.CONSTANT_ALPHA, DestFactor.ONE_MINUS_CONSTANT_ALPHA);
+  					}
+  					else{
+  						GlStateManager.disableBlend();
+  						GlStateManager.color4f(1, 1, 1, 1f);
+  						GL14.glBlendColor(1, 1, 1, 1);
+  					}
+
+  			        Vec3d pos = mc.vrPlayer.vrdata_world_render.getEye(mc.currentPass).getPosition();
+
+  			        boolean iamlazy = mc.vrSettings.vrHudLockMode == mc.vrSettings.HUD_LOCK_WRIST && MCOpenVR.hudPopup;
+  			        
+  					if (inMenuRoom || mc.currentScreen != null || iamlazy ||
+  							!this.mc.vrSettings.hudOcclusion 
+  							|| itemRenderer.isInsideOpaqueBlock(pos, false)){
+  						// Never use depth test for in game menu - so you can always see it!
+  						GlStateManager.depthFunc(GL11.GL_ALWAYS);
+  					} else {				
+  						GlStateManager.depthFunc(GL11.GL_LEQUAL);
+  					}
+  					
+  					if(mc.currentPass == renderPass.Third){
+  						GlStateManager.depthFunc(GL11.GL_LEQUAL);					}
+  					
+  					//the framebuffer has to be drawn with color blending transparency to support non-alpha cursors. Always has a black background.	
+                      GlStateManager.alphaFunc(GL11.GL_GREATER, 0.01f);
+  					GlStateManager.depthMask(true);
+  					GlStateManager.enableDepthTest();
+
+  					//Render framebuffer onto world projection
+  					ScaledResolution s = new ScaledResolution(mc);
+  							
+  					if(inMenuRoom)
+  						GlStateManager.disableAlphaTest();
+  					else
+  						GlStateManager.enableAlphaTest();
+  					
+  					GlStateManager.disableLighting();		
+  					
+  					drawSizedQuad(s.getScaledWidth(), s.getScaledHeight(), 1.5f); 
+
+  					GL14.glBlendColor(1, 1, 1, 1);
+  					GlStateManager.blendFunc(SourceFactor.SRC_ALPHA, DestFactor.ONE_MINUS_SRC_ALPHA);
+  					GlStateManager.enableDepthTest();
+  					GlStateManager.depthFunc(GL11.GL_LEQUAL);
+  					GlStateManager.enableCull();
+
+  	
+  			GL11.glMatrixMode(GL11.GL_MODELVIEW);
+  			GL11.glPopMatrix();
+  				
+  }
+
+  	//VIVE
+  	public void renderDebugAxes(int r, int g, int b, float radius){
+  		setupPolyRendering(true);
+  		renderCircle(new Vec3d(0, 0, 0), (float) radius, 32, r, g, b	, 255, 0);
+  		renderCircle(new Vec3d(0, .01, 0), (float) radius * .75f, 32, r, g, b	, 255, 0);
+  		renderCircle(new Vec3d(0,0.02, 0), (float) radius * .25f, 32, r, g, b	, 255, 0);
+  		renderCircle(new Vec3d(0, 0, .15), (float) radius *.5f, 32, r, g, b	, 255, 2);
+  		setupPolyRendering(false);
+  	}
+
+  	
+  	public void drawScreen(float par1, GuiScreen screen) {
+  		int mouseX = 0;
+  		int mouseY = 0;
+  		final ScaledResolution var15 = new ScaledResolution(this.mc);
+  		GL11.glDisable(GL11.GL_STENCIL_TEST);
+
+  		//Render all UI elements into guiFBO
+  		GlStateManager.clearColor(0, 0, 0, 0);
+  		GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+  		GlStateManager.matrixMode(GL11.GL_PROJECTION);
+  		GlStateManager.loadIdentity();
+  		GlStateManager.ortho(0.0D, var15.getScaledWidth_double(), var15.getScaledHeight_double(), 0.0D, 1000.0D, 3000.0D);
+  		GlStateManager.matrixMode(GL11.GL_MODELVIEW);
+  		GlStateManager.loadIdentity();
+  		GlStateManager.translatef(0.0F, 0.0F, -2000.0F);
+  		GlStateManager.blendFuncSeparate(SourceFactor.SRC_ALPHA, DestFactor.ONE_MINUS_SRC_ALPHA, SourceFactor.ONE, DestFactor.ZERO);
+
+  		screen.drawScreen(0, 0, par1);
+
+  		GlStateManager.disableLighting();
+  		GlStateManager.blendFuncSeparate(SourceFactor.SRC_ALPHA, DestFactor.ONE_MINUS_SRC_ALPHA, SourceFactor.ONE, DestFactor.ZERO);
+  		//inventory messes up fog color sometimes... This fixes
+
+  		//update mipmaps for Gui layer
+  		this.mc.getFramebuffer().bindFramebufferTexture();
+  		this.mc.getFramebuffer().genMipMaps();
+  		this.mc.getFramebuffer().unbindFramebufferTexture();
+  		GL11.glEnable(GL11.GL_STENCIL_TEST);
+
+  	}
+  	
+  	//TODO: move this into Guiingame where it belongs.
+  	/** This draws the normal 2d menu/GUI elements to the framebuffer, to be rendered into the world projection later (in renderFramebufferIntoWorld)
+  	 * @param renderPartialTicks
+  	 * @param tickDuration
+  	 */
+  	public void drawFramebuffer(float renderPartialTicks, long tickDuration)    // VIVE - added parameter for debug info
+  	{
+
+  		int mouseX = 0;
+  		int mouseY = 0;
+  		final ScaledResolution var15 = new ScaledResolution(this.mc);
+  		GL11.glDisable(GL11.GL_STENCIL_TEST);
+
+  		if (this.mc.showSplashScreen)
+  		{
+  			mc.showSplashScreen = false;
+  			//this.mc.showSplash(this.mc.getFramebuffer());
+  		}
+  		else if (false)//(this.mc.isIntegratedServerLaunching())
+  		{
+  			//			this.guiScreenShowingThisFrame = true;
+  			//			this.mc.loadingScreen.render();
+  		}
+  		else //always for vive, never for mono
+  		{
+  			if (
+  					(this.mc.world != null && this.mc.player.getSleepTimer() == 0) 
+  					|| 
+  					this.mc.currentScreen != null
+  					) //draw a thing
+  			{
+  				//Render all UI elements into guiFBO
+  				GlStateManager.clearColor(0, 0, 0, 0);
+  				GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+  				GlStateManager.matrixMode(GL11.GL_PROJECTION);
+  				GlStateManager.loadIdentity();
+  				GlStateManager.ortho(0.0D, var15.getScaledWidth_double(), var15.getScaledHeight_double(), 0.0D, 1000.0D, 3000.0D);
+  				GlStateManager.matrixMode(GL11.GL_MODELVIEW);
+  				GlStateManager.loadIdentity();
+  				GlStateManager.translatef(0.0F, 0.0F, -2000.0F);
+  				GlStateManager.blendFuncSeparate(SourceFactor.SRC_ALPHA, DestFactor.ONE_MINUS_SRC_ALPHA, SourceFactor.ONE, DestFactor.ZERO);
+
+  				// Display loading / progress window if necessary
+  				if (this.mc.world != null  /*&& !this.blankGUIUntilWorldValid*/)
+  				{
+  					//Draw in game HUD overlay
+  					GlStateManager.alphaFunc(GL11.GL_GREATER, 0.1F);
+
+  					Object fmlCommonHandler = null;
+  					if (Reflector.FMLCommonHandler_instance.exists()) {
+  						fmlCommonHandler = Reflector.call(Reflector.FMLCommonHandler_instance);
+  						Reflector.callVoid(fmlCommonHandler, Reflector.FMLCommonHandler_onRenderTickStart, new Object[]{renderPartialTicks});
+  					}
+
+  					if(!Main.viewonly){
+  						//Render HUD elements
+  						renderViveHudIcons();
+  						this.mc.ingameGUI.renderGameOverlay(renderPartialTicks);
+  					}
+
+  					if (this.mc.gameSettings.ofShowFps && !this.mc.gameSettings.showDebugInfo)
+  					{
+  						Config.drawFps();
+  					}
+
+  					//mc.guiAchievement.updateAchievementWindow();
+
+  					if (fmlCommonHandler != null) {
+  						Reflector.callVoid(fmlCommonHandler, Reflector.FMLCommonHandler_onRenderTickEnd, new Object[]{renderPartialTicks});		
+  					}
+
+  					GlStateManager.clear(GL11.GL_DEPTH_BUFFER_BIT);
+  				}
+
+  				//        if (this.blankGUIUntilWorldValid) {
+  				//            if (this.mc.world != null)
+  				//                this.blankGUIUntilWorldValid = false;
+  				//        }
+
+  				if (this.mc.currentScreen != null /*&& !this.blankGUIUntilWorldValid*/)
+  				{
+  					final int mouseX1 = mouseX = this.mc.currentScreen.getMouseXPos();
+  					final int mouseY1 = mouseY = this.mc.currentScreen.getMouseYPos();
+
+  					try
+  					{
+  						if(mc.currentScreen instanceof GuiContainer)
+  							GlStateManager.enableDepthTest(); //fixes inventory you.
+
+  						if(Reflector.forgeExists())
+  							Reflector.call(Reflector.ForgeHooksClient_drawScreen, this.mc.currentScreen, mouseX1, mouseY1, renderPartialTicks);
+  						else
+  							this.mc.currentScreen.drawScreen(mouseX, mouseY, renderPartialTicks);
+
+  						if(mc.currentScreen !=null){ 
+
+  							//	Draw GUI crosshair
+
+  							if(GuiHandler.controllerMouseValid)
+  								mc.ingameGUI.drawMouseMenuQuad(mc.currentScreen.getMouseXPos(),mc.currentScreen.getMouseYPos());				
+  						}
+  					}
+  					catch (Throwable throwable)
+  					{
+  						//duhhh.... wat
+  					}
+
+  					GlStateManager.disableLighting();
+  					GlStateManager.blendFuncSeparate(SourceFactor.SRC_ALPHA, DestFactor.ONE_MINUS_SRC_ALPHA, SourceFactor.ONE, DestFactor.ZERO);
+  					//inventory messes up fog color sometimes... This fixes
+
+  				}
+  			}
+  			// VIVE added debug info to HUD
+  			if (mc.gameSettings.showDebugInfo && mc.gameSettings.showDebugProfilerChart)
+  			{
+  				mc.displayDebugInfo(tickDuration);
+  			}
+  		}
+
+  		//update mipmaps for Gui layer
+  		this.mc.getFramebuffer().bindFramebufferTexture();
+  		this.mc.getFramebuffer().genMipMaps();
+  		this.mc.getFramebuffer().unbindFramebufferTexture();
+  		GL11.glEnable(GL11.GL_STENCIL_TEST);
+  	}
+
+  	private void renderTeleportArc(OpenVRPlayer vrPlayer) {
+
+  		if ( mc.teleportTracker.vrMovementStyle.showBeam && mc.teleportTracker.isAiming()
+  				&& mc.teleportTracker.movementTeleportArcSteps > 1)
+  		{
+  			mc.profiler.startSection("teleportArc");
+
+  			boolean isShader = Config.isShaders();
+  	        GlStateManager.enableCull();
+
+  			Tessellator tes = Tessellator.getInstance();
+  			tes.getBuffer().begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_COLOR);
+  			
+  				double VOffset = mc.teleportTracker.lastTeleportArcDisplayOffset;
+  				Vec3d dest = mc.teleportTracker.getDestination();
+  				
+  				boolean validLocation = (dest.x != 0
+  						|| dest.y != 0
+  						|| dest.z != 0);
+  	
+  				
+  				Vec3i color;
+  				byte alpha = (byte) 255;
+  		
+  				if (!validLocation)
+  				{
+  					// invalid location
+  					color = new Vec3i(83, 75, 83);
+  					alpha = (byte) 128;
+  				}
+  				else
+  				{
+  					if(mc.vrSettings.vrLimitedSurvivalTeleport && !mc.player.capabilities.allowFlying)
+  						color = tpLimitedColor;
+  					else
+  						color = tpUnlimitedColor;
+  					
+  					VOffset = this.mc.stereoProvider.getCurrentTimeSecs()*mc.teleportTracker.vrMovementStyle.textureScrollSpeed * 0.6;
+  					mc.teleportTracker.lastTeleportArcDisplayOffset = VOffset;
+  				}
+
+  				float segmentHalfWidth = mc.teleportTracker.vrMovementStyle.beamHalfWidth * 0.15f;
+  				int segments = mc.teleportTracker.movementTeleportArcSteps - 1;
+  				if (mc.teleportTracker.vrMovementStyle.beamGrow)
+  				{
+  					segments = (int) ((double) segments * mc.teleportTracker.movementTeleportProgress);
+  				}
+  				double segmentProgress = 1.0 / (double) segments;
+  	
+  				Vec3d up = new Vec3d(0,1,0);
+  	
+  				for (int i=0;i<segments;i++)
+  				{
+  					double progress = ((double)i / (double)segments) + VOffset * segmentProgress;
+  					int progressBase = (int)MathHelper.floor(progress);
+  					progress -= (float) progressBase;
+  	
+  					Vec3d start = mc.teleportTracker.getInterpolatedArcPosition((float)(progress - segmentProgress * 0.4f))
+  							.subtract(mc.getRenderViewEntity().getPositionVector());
+
+  	
+  					Vec3d end = mc.teleportTracker.getInterpolatedArcPosition((float)progress)
+  							.subtract(mc.getRenderViewEntity().getPositionVector());
+  	
+  					float shift = (float)progress * 2.0f;
+  					renderBox(tes, start, end, -segmentHalfWidth, segmentHalfWidth, (-1.0f + shift ) * segmentHalfWidth, (1.0f + shift) * segmentHalfWidth, up, color, alpha);
+  				}
+  				
+  			tes.draw();
+  	        GlStateManager.disableCull();
+
+  			if (validLocation && mc.teleportTracker.movementTeleportProgress >=1){ //draw landing splash
+  				Vec3d circlePos = new Vec3d(dest.x, dest.y, dest.z) 
+  						.subtract(mc.getRenderViewEntity().getPositionVector());
+
+  				int side = 1; //vrPlayer.movementTeleportDestinationSideHit;
+
+  				float o = 0.01f;
+  				
+  				double x = 0;
+  				double y = 0;
+  				double z = 0;
+
+  				if (side ==0)   y -= o;
+  				if (side ==1)   y += o;
+  				if (side ==2)   z -= o;
+  				if (side ==3)   z += o;
+  				if (side ==4)   x -= o;
+  				if (side ==5)   x += o;		
+  				renderFlatQuad(circlePos.add(x, y, z), .6f,.6f, 0,(int)(color.getX()*1.03), (int)(color.getY()*1.03), (int)(color.getZ()*1.03), isShader ? 255 : 64);
+  				if (side ==0)   y -= o;
+  				if (side ==1)   y += o;
+  				if (side ==2)   z -= o;
+  				if (side ==3)   z += o;
+  				if (side ==4)   x -= o;
+  				if (side ==5)   x += o;
+  				renderFlatQuad(circlePos.add(x, y, z), .4f,.4f, 0,(int)(color.getX()*1.04), (int)(color.getY()*1.04), (int)(color.getZ()*1.04), isShader ? 255 : 64);
+  				if (side ==0)   y -= o;
+  				if (side ==1)   y += o;
+  				if (side ==2)   z -= o;
+  				if (side ==3)   z += o;
+  				if (side ==4)   x -= o;
+  				if (side ==5)   x += o;
+  				renderFlatQuad(circlePos.add(x, y, z), .2f,.2f, 0,(int)(color.getX()*1.05), (int)(color.getY()*1.05), (int)(color.getZ()*1.05), isShader ? 255 : 64);
+  			}
+
+  			mc.profiler.endSection(); // teleport arc
+  		}
+  	}
+
+  	
+  	//please push your matrix first. and pop after.
+  	public void SetupRenderingAtController(int controller){
+  		
+  		Vec3d aimSource = getControllerRenderPos(controller);
+  		aimSource = aimSource.subtract(mc.getRenderViewEntity().getPositionVector());
+  		
+  		if (aimSource!=null)
+  		{ //move from head to hand origin.
+  				GL11.glTranslatef(
+  					(float) (aimSource.x ),
+  					(float) (aimSource.y ),
+  					(float) (aimSource.z ));
+  		}
+  	
+
+  			GL11.glScalef(mc.vrPlayer.vrdata_world_render.worldScale , mc.vrPlayer.vrdata_world_render.worldScale , mc.vrPlayer.vrdata_world_render.worldScale);
+  		
+      //    	Vector3f fore = new Vector3f(0,0,1);       
+     //     	Matrix4f rotation = this.mc.vrPlayer.get.getAimRotation(controller);  
+          	
+          	FloatBuffer buf = mc.vrPlayer.vrdata_world_render.getController(controller).getMatrix().transposed().toFloatBuffer();
+          	//I have no idea why this has to be transposed.
+          	
+  	    	if(!mc.bowTracker.isDrawing || controller == 0){ //doing this elsewhere
+  	    		GL11.glMultMatrixf(buf);      
+          	}     
+  	    	
+  	}
+  	
+  	boolean okshader = true;
+  	
+  	// VIVE START - render functions
+  	public void renderHandVR_Offhand(float nano)
+  	{
+  		boolean shadersMod = Config.isShaders() && okshader;
+  		boolean shadersModShadowPass = false;
+  		
+  		//from player face to HMD
+  		setupCameraTransform(nano);
+  		applyCameraDepth(false);
+  		if(shadersMod){
+  			shadersModShadowPass = Shaders.isShadowPass;
+  			Shaders.beginHand(true);
+  		}
+  		else {
+  			GL11.glMatrixMode(GL11.GL_PROJECTION);
+  			GL11.glPushMatrix();
+  			GL11.glMatrixMode(GL11.GL_MODELVIEW);
+  			GL11.glPushMatrix();
+  		}
+  			
+  			GL11.glPushMatrix();
+
+  				SetupRenderingAtController(1);	//does not push
+  				
+  				mc.getTextureManager().bindTexture(mc.player.getLocationSkin());
+
+  				GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL12.GL_CLAMP_TO_EDGE);
+  				GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL12.GL_CLAMP_TO_EDGE);
+  				GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST);
+  				GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_NEAREST);	
+  	
+  		        GlStateManager.enableRescaleNormal();
+  		        ItemStack item = mc.player.getHeldItemOffhand();
+  		        
+  				if(mc.climbTracker.isClimbeyClimb() && (item==null || item.getItem() != Items.SHEARS)){
+  					itemRenderer.renderItemInFirstPerson(mc.player, nano, 0, EnumHand.OFF_HAND, mc.player.getSwingProgress(nano), mc.player.getHeldItemMainhand(), 0);
+  				}
+  						        
+  					if(BowTracker.isHoldingBow(mc.player, EnumHand.MAIN_HAND)){ //render bow
+  						int c = 1;
+  						if (mc.vrSettings.vrReverseShootingEye) c = 0;
+  						itemRenderer.renderItemInFirstPerson(mc.player, nano, 0, EnumHand.OFF_HAND, mc.player.getSwingProgress(nano), mc.player.getHeldItemMainhand(), 0);
+  					}
+  					else //just hand
+  						itemRenderer.renderItemInFirstPerson(mc.player, nano, 0, EnumHand.OFF_HAND, mc.player.getSwingProgress(nano), item, 0);
+  			    GlStateManager.disableRescaleNormal();
+  		
+
+  			GL11.glPopMatrix();//back to hmd rendering
+  					
+  											
+  			setupPolyRendering(true);
+  			
+  					//	TP energy
+  				if (mc.vrSettings.vrLimitedSurvivalTeleport && !mc.vrPlayer.getFreeMove() && mc.playerController.isNotCreative() && mc.teleportTracker.vrMovementStyle.arcAiming && !mc.bowTracker.isActive(mc.player)){
+  					GL11.glPushMatrix();
+  						SetupRenderingAtController(1);	//does not push
+  			
+  						Vec3d start = new Vec3d(0,0.005,.03);
+  			
+  						float r;
+  						float max = .03f;
+  						if (mc.teleportTracker.isAiming()) {      	
+  							r = 2*(float) ( mc.teleportTracker.getTeleportEnergy() - 4 * mc.teleportTracker.movementTeleportDistance  ) / 100 * max;
+  						} else {     	
+  							r = 2*mc.teleportTracker.getTeleportEnergy() / 100 * max;
+  						}
+  			
+  						if(r<0){r=0;}
+  						renderFlatQuad(start.add(0, .05001, 0), r,r,0, tpLimitedColor.getX(), tpLimitedColor.getY(), tpLimitedColor.getZ(), 128);
+  						renderFlatQuad(start.add(0, .05, 0), max,max,0, tpLimitedColor.getX(), tpLimitedColor.getY(), tpLimitedColor.getZ(), 50);    
+  			
+  					GL11.glPopMatrix();
+  				}
+  				
+  				if(!mc.vrPlayer.getFreeMove()){ //actually rendered from the head, not hand.
+  					GL11.glPushMatrix();
+  					GlStateManager.enableDepthTest();
+  						if(mc.teleportTracker.vrMovementStyle.arcAiming) {						
+  							renderTeleportArc(mc.vrPlayer);
+  						} else {
+  							//renderTeleportLine(mc.vrPlayer); 	
+  						}
+  					GL11.glPopMatrix();
+  				}
+
+  				setupPolyRendering(false);
+  			
+  		if(shadersMod)
+  			Shaders.endHand();
+  		else {
+  			GL11.glMatrixMode(GL11.GL_PROJECTION);
+  			GL11.glPopMatrix();
+  			GL11.glMatrixMode(GL11.GL_MODELVIEW);
+  			GL11.glPopMatrix();
+  		}	
+  	}
+
+  	private void renderMainMenuHands()
+  	{
+  		GL11.glMatrixMode(GL11.GL_PROJECTION);
+  		GL11.glPushMatrix();
+  			GL11.glLoadIdentity();
+  			if (mc.currentPass != renderPass.Third && mc.currentPass != renderPass.Center)
+  			{
+  				int i = mc.currentPass.value();
+  				if(i>1) i = 0;
+  				GL11.glMultMatrixf(mc.eyeproj[i]);
+  			} else {
+  				if (mc.currentPass == renderPass.Third) {
+  					Project.gluPerspective(this.mc.vrSettings.mixedRealityFov, this.mc.vrSettings.mixedRealityAspectRatio, minClipDistance, clipDistance);
+  				} else {
+  					Project.gluPerspective(this.mc.gameSettings.fovSetting, (float)this.mc.displayWidth / (float) this.mc.displayHeight, minClipDistance, clipDistance);
+  				}
+  			}
+  			GL11.glMatrixMode(GL11.GL_MODELVIEW);
+  			GL11.glPushMatrix();
+  				GL11.glLoadIdentity();
+  		
+  				GlStateManager.disableTexture2D();
+  				GlStateManager.disableAlphaTest();
+  				GlStateManager.disableDepthTest();
+  						
+  				// counter head rotation
+  				if (mc.currentPass != renderPass.Third) {
+  					GL11.glMultMatrixf(mc.vrPlayer.vrdata_world_render.hmd.getMatrix().toFloatBuffer());
+  				} else {
+  					applyMRCameraRotation(false);				}
+
+  				
+  				//OK SO when world == null the origin is at your face.
+  							
+  				Tessellator tes = Tessellator.getInstance();
+  		
+  				for (int c=0;c<2;c++)
+  				{
+  		
+  					Vec3i color = new Vec3i((byte)(255 - 127 * c), (byte)(255 - 127 * c), (byte)(255 - 127 * c));
+  					byte alpha = (byte) 255;
+  					Vec3d controllerPos = mc.vrPlayer.vrdata_world_render.getEye(mc.currentPass).getPosition()
+  							.subtract(getControllerRenderPos(c));
+  					
+  					GL11.glPushMatrix();
+  										
+  						GL11.glTranslatef(
+  								(float)-controllerPos.x,
+  								(float)-controllerPos.y,
+  								(float)-controllerPos.z);
+  									
+  						Vec3d start = new Vec3d(0,0,0);
+  			
+//  						Matrix4f controllerRotation = mc.lookaimController.getAimRotation(c);
+//  						Vector3f forward = new Vector3f(0,0,-0.17f);
+//  						Vector3f dir = controllerRotation.transform(forward);
+  						Vec3d dir = mc.vrPlayer.vrdata_world_render.getController(c).getDirection();
+  						Vec3d up = mc.vrPlayer.vrdata_world_render.getController(c).getCustomVector(new Vec3d(0, 1, 0));
+  				
+  						float sc = mc.vrPlayer.vrdata_world_render.worldScale;
+
+  						Vec3d end = new Vec3d(
+  								start.x - dir.x*.18*sc,
+  								start.y - dir.y*.18*sc,
+  								start.z - dir.z*.18*sc);
+  			
+  						
+  						tes.getBuffer().begin(7, DefaultVertexFormats.POSITION_COLOR);
+  						renderBox(tes, start, end, -0.02f*sc, 0.02f*sc, -0.025f*sc, 0.00f*sc, up, color, alpha);
+  						tes.draw();
+  					GL11.glPopMatrix();     
+  				}
+  		
+  			
+  				GlStateManager.enableTexture2D();
+
+  			GL11.glPopMatrix();
+  		GL11.glMatrixMode(GL11.GL_PROJECTION);
+  	GL11.glPopMatrix();
+  	}
+
+  	public void renderFlatQuad(Vec3d pos, float width, float height,float yaw, int r, int g, int b, int a)
+  	{
+  		Tessellator tes = Tessellator.getInstance();
+  		
+  		tes.getBuffer().begin(GL11.GL_QUADS,DefaultVertexFormats.POSITION_COLOR);
+
+  		Vec3d lr = new Vec3d(-width/2,0, height/2).rotateYaw((float) Math.toRadians(-yaw));
+  		Vec3d ls = new Vec3d(-width/2,0, -height/2).rotateYaw((float) Math.toRadians(-yaw));
+  		Vec3d lt = new Vec3d(width/2,0, -height/2).rotateYaw((float) Math.toRadians(-yaw));
+  		Vec3d lu = new Vec3d(width/2,0, height/2).rotateYaw((float) Math.toRadians(-yaw));
+
+  		tes.getBuffer().pos(pos.x + lr.x, pos.y, pos.z + lr.z).color(r, g, b, a).endVertex();
+  		tes.getBuffer().pos(pos.x + ls.x, pos.y, pos.z + ls.z).color(r, g, b, a).endVertex();
+  		tes.getBuffer().pos(pos.x + lt.x, pos.y, pos.z + lt.z).color(r, g, b, a).endVertex();
+  		tes.getBuffer().pos(pos.x + lu.x, pos.y, pos.z + lu.z).color(r, g, b, a).endVertex();
+  		
+  		tes.draw();  
+  	}
+  	
+  	public void renderCircle(Vec3d pos, float radius, int edges, int r, int g, int b, int a, int side)
+  	{
+  		Tessellator tes = Tessellator.getInstance();
+  		
+  		tes.getBuffer().begin(GL11.GL_TRIANGLE_FAN,DefaultVertexFormats.POSITION_COLOR);
+
+  		tes.getBuffer().pos(pos.x, pos.y, pos.z).color(r, g, b, a).endVertex();
+
+  		for (int i=0;i<edges + 1;i++)
+  		{
+  			float startAngle;
+  			startAngle = ( (float) (i) / (float) edges ) * (float) Math.PI * 2.0f;
+
+  			if (side == 0 || side == 1) { //y
+  				float x = (float) pos.x + (float) Math.cos(startAngle) * radius;
+  				float y = (float) pos.y;
+  				float z = (float) pos.z + (float) Math.sin(startAngle) * radius;
+  				tes.getBuffer().pos(x, y, z).color(r, g, b, a).endVertex();
+  			} else if (side == 2 || side == 3) { //z
+  				float x = (float) pos.x + (float) Math.cos(startAngle) * radius;
+  				float y = (float) pos.y + (float) Math.sin(startAngle) * radius;
+  				float z = (float) pos.z; 
+  				tes.getBuffer().pos(x, y, z).color(r, g, b, a).endVertex();
+  			} else if (side == 4 || side == 5){ //x
+  				float x = (float) pos.x ;
+  				float y = (float) pos.y + (float) Math.cos(startAngle) * radius;
+  				float z = (float) pos.z + (float) Math.sin(startAngle) * radius;
+  				tes.getBuffer().pos(x, y, z).color(r, g, b, a).endVertex();
+  			} else{}
+
+  		}
+  		
+  		tes.draw();       
+
+  	}
+
+  	private void renderBox(Tessellator tes, Vec3d start, Vec3d end, float minX, float maxX, float minY, float maxY, Vec3d up, Vec3i color, byte alpha)
+  	{
+  		Vec3d forward = start.subtract(end).normalize();
+  		Vec3d right = forward.crossProduct(up);
+  		up = right.crossProduct(forward);
+  	
+  		Vec3d left = new Vec3d(
+  				right.x * minX,
+  				right.y * minX,
+  				right.z * minX);
+  	
+  		right = right.scale(maxX);
+  		
+  	
+  		Vec3d down = new Vec3d(
+  				up.x * minY,
+  				up.y * minY,
+  				up.z * minY);
+  	
+  		up = up.scale(maxY);
+
+  	
+  		Vec3d backRightBottom    = start.add(   right.x+down.x,   right.y+down.y,   right.z+down.z);
+  		Vec3d backRightTop       = start.add(   right.x+up.x,     right.y+up.y,     right.z+up.z);
+  		Vec3d backLeftBottom     = start.add(   left.x+down.x,    left.y+down.y,    left.z+down.z);
+  		Vec3d backLeftTop        = start.add(   left.x+up.x,      left.y+up.y,      left.z+up.z);
+  		Vec3d frontRightBottom   = end.add(     right.x+down.x,   right.y+down.y,   right.z+down.z);
+  		Vec3d frontRightTop      = end.add(     right.x+up.x,     right.y+up.y,     right.z+up.z);
+  		Vec3d frontLeftBottom    = end.add(     left.x+down.x,    left.y+down.y,    left.z+down.z);
+  		Vec3d frontLeftTop       = end.add(     left.x+up.x,      left.y+up.y,      left.z+up.z);
+  	
+  		BufferBuilder b = tes.getBuffer();
+  		
+  		b.pos(backRightBottom.x, backRightBottom.y, backRightBottom.z).color(color.getX(), color.getY(), color.getZ(), alpha).endVertex();
+  		b.pos(backRightTop.x, backRightTop.y, backRightTop.z).color(color.getX(), color.getY(), color.getZ(), alpha).endVertex();
+  		b.pos(backLeftTop.x, backLeftTop.y, backLeftTop.z).color(color.getX(), color.getY(), color.getZ(), alpha).endVertex();
+  		b.pos(backLeftBottom.x, backLeftBottom.y, backLeftBottom.z).color(color.getX(), color.getY(), color.getZ(), alpha).endVertex();    // back
+  	
+  		b.pos(frontLeftBottom.x, frontLeftBottom.y, frontLeftBottom.z).color(color.getX(), color.getY(), color.getZ(), alpha).endVertex();   // front
+  		b.pos(frontLeftTop.x, frontLeftTop.y, frontLeftTop.z).color(color.getX(), color.getY(), color.getZ(), alpha).endVertex();
+  		b.pos(frontRightTop.x, frontRightTop.y, frontRightTop.z).color(color.getX(), color.getY(), color.getZ(), alpha).endVertex();
+  		b.pos(frontRightBottom.x, frontRightBottom.y, frontRightBottom.z).color(color.getX(), color.getY(), color.getZ(), alpha).endVertex();
+  	
+  		b.pos(frontRightBottom.x, frontRightBottom.y, frontRightBottom.z).color(color.getX(), color.getY(), color.getZ(), alpha).endVertex();    // right
+  		b.pos(frontRightTop.x, frontRightTop.y, frontRightTop.z).color(color.getX(), color.getY(), color.getZ(), alpha).endVertex();
+  		b.pos(backRightTop.x, backRightTop.y, backRightTop.z).color(color.getX(), color.getY(), color.getZ(), alpha).endVertex();
+  		b.pos(backRightBottom.x, backRightBottom.y, backRightBottom.z).color(color.getX(), color.getY(), color.getZ(), alpha).endVertex();
+  	
+  		b.pos(backLeftBottom.x, backLeftBottom.y, backLeftBottom.z).color(color.getX(), color.getY(), color.getZ(), alpha).endVertex(); // left
+  		b.pos(backLeftTop.x, backLeftTop.y, backLeftTop.z).color(color.getX(), color.getY(), color.getZ(), alpha).endVertex();
+  		b.pos(frontLeftTop.x, frontLeftTop.y, frontLeftTop.z).color(color.getX(), color.getY(), color.getZ(), alpha).endVertex();
+  		b.pos(frontLeftBottom.x, frontLeftBottom.y, frontLeftBottom.z).color(color.getX(), color.getY(), color.getZ(), alpha).endVertex();
+  	
+  		b.pos(backLeftTop.x, backLeftTop.y, backLeftTop.z).color(color.getX(), color.getY(), color.getZ(), alpha).endVertex();
+  		b.pos(backRightTop.x, backRightTop.y, backRightTop.z).color(color.getX(), color.getY(), color.getZ(), alpha).endVertex();
+  		b.pos(frontRightTop.x, frontRightTop.y, frontRightTop.z).color(color.getX(), color.getY(), color.getZ(), alpha).endVertex();
+  		b.pos(frontLeftTop.x, frontLeftTop.y, frontLeftTop.z).color(color.getX(), color.getY(), color.getZ(), alpha).endVertex();       // top
+  	
+  		b.pos(frontLeftBottom.x, frontLeftBottom.y, frontLeftBottom.z).color(color.getX(), color.getY(), color.getZ(), alpha).endVertex();       // bottom
+  		b.pos(frontRightBottom.x, frontRightBottom.y, frontRightBottom.z).color(color.getX(), color.getY(), color.getZ(), alpha).endVertex();
+  		b.pos(backRightBottom.x, backRightBottom.y, backRightBottom.z).color(color.getX(), color.getY(), color.getZ(), alpha).endVertex();
+  		b.pos(backLeftBottom.x, backLeftBottom.y, backLeftBottom.z).color(color.getX(), color.getY(), color.getZ(), alpha).endVertex();
+  	}
+
+  	//awesome.
+  	private void renderJrbuddasAwesomeMainMenuRoom() {
+  		GlStateManager.clearColor(.1f, .1f, .1f, 0.1f);       
+  		GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT);        
+  		GlStateManager.disableBlend();   
+  		GlStateManager.color4f(0.5f, 0.5f, 0.5f, 1f);
+  		
+  		GlStateManager.enableDepthTest();
+  		GlStateManager.enableTexture2D();
+  		GlStateManager.enableLighting();
+  		GlStateManager.enableLight(0);
+  		GlStateManager.enableCull();
+  		GlStateManager.enableColorMaterial();
+  		GlStateManager.colorMaterial(GL11.GL_FRONT_AND_BACK, GL11.GL_AMBIENT_AND_DIFFUSE);
+  		
+  		Minecraft.getMinecraft().renderEngine.bindTexture(Gui.OPTIONS_BACKGROUND);
+  		
+  		//float yo = -camRelY;
+  		int repeat = 4; // texture wraps per meter
+  		float height = 2.5f;
+  		float oversize = 1f;
+  		
+  		float[] area = MCOpenVR.getPlayAreaSize();
+  		if (area != null) {
+  			float width = area[0] + oversize;
+  			float length = area[1] + oversize;
+  			GL11.glPushMatrix();
+  				GL11.glTranslatef(-width / 2, 0, -length / 2);
+  				GL11.glLight(GL11.GL_LIGHT0, GL11.GL_POSITION, setFogColorBuffer(width / 2, 1.8f, length / 2, 1));           
+  				GL11.glLight(GL11.GL_LIGHT0, GL11.GL_DIFFUSE, setFogColorBuffer(1.0F, 1.0F, 1.0F, 1.0F));
+  				GL11.glLight(GL11.GL_LIGHT0, GL11.GL_AMBIENT, setFogColorBuffer(0.2F, 0.2F, 0.2F, 1.0F));
+  				GL11.glLight(GL11.GL_LIGHT0, GL11.GL_SPECULAR, setFogColorBuffer(1.0F, 1.0F, 1.0F, 1.0F));
+  				GL11.glLight(GL11.GL_LIGHT0, GL11.GL_CONSTANT_ATTENUATION, setFogColorBuffer(1.0F, 0, 0, 0));
+  				GL11.glLight(GL11.GL_LIGHT0, GL11.GL_LINEAR_ATTENUATION, setFogColorBuffer(0.0F, 0, 0, 0));
+  				GL11.glLight(GL11.GL_LIGHT0, GL11.GL_QUADRATIC_ATTENUATION, setFogColorBuffer(0.0F, 0, 0, 0));
+  				GlStateManager.glLightModel(GL11.GL_LIGHT_MODEL_AMBIENT, setFogColorBuffer(0, 0, 0, 1.0F));		
+  				GlStateManager.shadeModel(GL11.GL_SMOOTH);
+
+  				GL11.glBegin(GL11.GL_QUADS);
+  					GL11.glNormal3f(0, 1, 0);
+  					GL11.glTexCoord2f(0, 0);
+  					GL11.glVertex3f(0, 0, 0);
+  					GL11.glTexCoord2f(0, repeat * length);
+  					GL11.glVertex3f(0, 0, length);
+  					GL11.glTexCoord2f(repeat * width, repeat * length);
+  					GL11.glVertex3f(width, 0, length);
+  					GL11.glTexCoord2f(repeat * width, 0);
+  					GL11.glVertex3f(width, 0, 0);
+  				GL11.glEnd();
+  				GL11.glBegin(GL11.GL_QUADS);
+  					GL11.glNormal3f(0, -1, 0);
+  					GL11.glTexCoord2f(0, 0);
+  					GL11.glVertex3f(0, height, 0);
+  					GL11.glTexCoord2f(repeat * width, 0);
+  					GL11.glVertex3f(width, height, 0);
+  					GL11.glTexCoord2f(repeat * width, repeat * length);
+  					GL11.glVertex3f(width, height, length);
+  					GL11.glTexCoord2f(0, repeat * length);
+  					GL11.glVertex3f(0, height, length);
+  				GL11.glEnd();
+  				GL11.glBegin(GL11.GL_QUADS);
+  					GL11.glNormal3f(1, 0, 0);
+  					GL11.glTexCoord2f(0, 0);
+  					GL11.glVertex3f(0, 0, 0);
+  					GL11.glTexCoord2f(0, repeat * height);
+  					GL11.glVertex3f(0, height, 0);
+  					GL11.glTexCoord2f(repeat * length, repeat * height);
+  					GL11.glVertex3f(0, height, length);
+  					GL11.glTexCoord2f(repeat * length, 0);
+  					GL11.glVertex3f(0, 0, length);
+  				GL11.glEnd();
+  				GL11.glBegin(GL11.GL_QUADS);
+  					GL11.glNormal3f(-1, 0, 0);
+  					GL11.glTexCoord2f(0, 0);
+  					GL11.glVertex3f(width, 0, 0);
+  					GL11.glTexCoord2f(repeat * length, 0);
+  					GL11.glVertex3f(width, 0, length);
+  					GL11.glTexCoord2f(repeat * length, repeat * height);
+  					GL11.glVertex3f(width, height, length);
+  					GL11.glTexCoord2f(0, repeat * height);
+  					GL11.glVertex3f(width, height, 0);
+  				GL11.glEnd();
+  				GL11.glBegin(GL11.GL_QUADS);
+  					GL11.glNormal3f(0, 0, 1);
+  					GL11.glTexCoord2f(0, 0);
+  					GL11.glVertex3f(0, 0, 0);
+  					GL11.glTexCoord2f(repeat * width, 0);
+  					GL11.glVertex3f(width, 0, 0);
+  					GL11.glTexCoord2f(repeat * width, repeat * height);
+  					GL11.glVertex3f(width, height, 0);
+  					GL11.glTexCoord2f(0, repeat * height);
+  					GL11.glVertex3f(0, height, 0);
+  				GL11.glEnd();
+  				GL11.glBegin(GL11.GL_QUADS);
+  					GL11.glNormal3f(0, 0, -1);
+  					GL11.glTexCoord2f(0, 0);
+  					GL11.glVertex3f(0, 0, length);
+  					GL11.glTexCoord2f(0, repeat * height);
+  					GL11.glVertex3f(0, height, length);
+  					GL11.glTexCoord2f(repeat * width, repeat * height);
+  					GL11.glVertex3f(width, height, length);
+  					GL11.glTexCoord2f(repeat * width, 0);
+  					GL11.glVertex3f(width, 0, length);
+  				GL11.glEnd();
+  			GL11.glPopMatrix();
+  		}
+  	
+  		RenderHelper.disableStandardItemLighting();
+  	}
+
+  	private void renderTechjarsAwesomeMainMenuRoom() {
+  		GlStateManager.color4f(1f, 1f, 1f, 1f);
+  		
+  		GlStateManager.enableDepthTest();
+  		GlStateManager.enableTexture2D();
+  		GlStateManager.enableBlend();
+  		GlStateManager.enableAlphaTest();
+  		GlStateManager.enableCull();
+  		
+  		GL11.glPushMatrix();
+
+  		boolean shaders = Shaders.shaderPackLoaded;
+  		Shaders.shaderPackLoaded = false;
+
+  		int tzOffset = Calendar.getInstance().get(Calendar.ZONE_OFFSET);
+  		mc.menuWorldRenderer.time = menuWorldFastTime ? (long)((this.mc.tickCounter * 10) + 10 * mc.timer.renderPartialTicks) : (long)((System.currentTimeMillis() + tzOffset - 21600000) / 86400000D * 24000D);
+  		Vec3d hmd = mc.vrPlayer.vrdata_room_post.hmd.getPosition();
+  		float posX = (float) hmd.x;
+  		float posY = (float) (hmd.y + mc.menuWorldRenderer.getWorld().getGround());
+  		float posZ = (float) hmd.z;
+
+  		Vec3d fogColor = mc.menuWorldRenderer.getFogColor();
+  		GlStateManager.clearColor((float)fogColor.x, (float)fogColor.y, (float)fogColor.z, 1);
+  		GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT);
+  		GlStateManager.enableFog();
+  		GlStateManager.glFog(GL11.GL_FOG_COLOR, setFogColorBuffer((float)fogColor.x, (float)fogColor.y, (float)fogColor.z, 1));
+  		GlStateManager.fogStart(mc.menuWorldRenderer.getWorld().getXSize() / 2 - 32);
+  		GlStateManager.fogEnd(mc.menuWorldRenderer.getWorld().getXSize() / 2);
+  		GlStateManager.fogMode(FogMode.LINEAR);
+  		if (GL.getCapabilities().GL_NV_fog_distance) {
+  			// Makes fog look nicer, but only works on NVIDIA cards. AMD cards require a shader.
+  			GlStateManager.fogi(NVFogDistance.GL_FOG_DISTANCE_MODE_NV, NVFogDistance.GL_EYE_RADIAL_NV);
+  		}
+  		
+  		mc.menuWorldRenderer.renderSky(posX, posY, posZ, 2);
+
+          if (posY < 128.0D + (double)(this.mc.gameSettings.ofCloudsHeight * 128.0F)) {
+          	mc.menuWorldRenderer.renderClouds(2, posX, posY, posZ);
+          }
+
+  		GlStateManager.blendFunc(SourceFactor.SRC_ALPHA, DestFactor.ONE_MINUS_SRC_ALPHA);
+  		GlStateManager.enableBlend();
+
+  		mc.menuWorldRenderer.updateLightmap();
+  		mc.menuWorldRenderer.render();
+  		
+          if (posY >= 128.0D + (double)(this.mc.gameSettings.ofCloudsHeight * 128.0F)) {
+          	mc.menuWorldRenderer.renderClouds(2, posX, posY, posZ);
+      		GlStateManager.blendFunc(SourceFactor.SRC_ALPHA, DestFactor.ONE_MINUS_SRC_ALPHA);
+      		GlStateManager.enableBlend();
+          }
+
+  		float[] area = MCOpenVR.getPlayAreaSize();
+  		if (area != null) {
+  			float width = (float)Math.ceil(area[0]);
+  			float length = (float)Math.ceil(area[1]);
+
+  			Minecraft.getMinecraft().renderEngine.bindTexture(Gui.OPTIONS_BACKGROUND);
+  			float sun = mc.menuWorldRenderer.getSunBrightness();
+  			GlStateManager.color4f(sun, sun, sun, 0.3f);
+  			GL11.glTranslatef(-width / 2, 0, -length / 2);
+  			GL11.glBegin(GL11.GL_QUADS);
+  				GL11.glNormal3f(0, 1, 0);
+  				GL11.glTexCoord2f(0, 0);
+  				GL11.glVertex3f(0, 0.001f, 0);
+  				GL11.glTexCoord2f(0, length);
+  				GL11.glVertex3f(0, 0.001f, length);
+  				GL11.glTexCoord2f(width, length);
+  				GL11.glVertex3f(width, 0.001f, length);
+  				GL11.glTexCoord2f(width, 0);
+  				GL11.glVertex3f(width, 0.001f, 0);
+  			GL11.glEnd();
+  		}
+  		
+  		Shaders.shaderPackLoaded = shaders;
+  		
+  		GL11.glPopMatrix();
+  		GlStateManager.disableFog();
+  	}
+  	
+  	public void renderCrosshairAtDepth()
+  	{
+  		if(Main.viewonly) return;
+  		//Draw crosshair
+  		boolean renderCrosshair = this.mc.vrSettings.renderInGameCrosshairMode == VRSettings.RENDER_CROSSHAIR_MODE_ALWAYS ||
+  				(this.mc.vrSettings.renderInGameCrosshairMode == VRSettings.RENDER_CROSSHAIR_MODE_HUD && !this.mc.gameSettings.hideGUI);
+  		
+  		// VIVE start - don't render crosshair while teleporting
+  		if (mc.teleportTracker.isAiming())
+  		{
+  			renderCrosshair = false;
+  		}
+  		
+  		if (mc.climbTracker.isGrabbingLadder() && mc.climbTracker.latchStartController == 0)
+  		{
+  			renderCrosshair = false;
+  		}
+  		
+  		if (mc.climbTracker.isClimbeyClimb() && mc.climbTracker.isGrabbingLadder() && (mc.objectMouseOver==null || mc.objectMouseOver.entity == null))
+  		{
+  			renderCrosshair = false;
+  		}
+  		
+  		if (mc.currentPass == renderPass.Third) //it doesn't look very good.
+  		{
+  			renderCrosshair = false;
+  		}
+
+
+  		// VIVE end
+
+  		if( this.mc.currentScreen == null && this.mc.gameSettings.thirdPersonView == 0 && renderCrosshair && !KeyboardHandler.Showing && !mc.bowTracker.isDrawing)
+  		{
+  			this.mc.profiler.endStartSection("crosshair");
+  			
+  			GlStateManager.color4f(1.0f, 1.0f, 1.0f, 1.0f); //white crosshair, with blending
+  			
+  			Vec3d aim = crossVec.subtract(mc.vrPlayer.vrdata_world_render.getController(0).getPosition());
+  			float crossDepth =(float)aim.length();
+  			if (crossDepth > MAX_CROSSHAIR_DISTANCE) crossDepth = MAX_CROSSHAIR_DISTANCE;
+  			float scale = (float) (0.15f* this.mc.vrSettings.crosshairScale * Math.sqrt(mc.vrPlayer.vrdata_world_render.worldScale));
+  		
+
+  			Vec3d adj = crossVec.add((aim.normalize()).scale(-0.01));
+
+  			if(mc.world != null){
+  				int minLight = Config.isShaders() ? 8 : 4; 
+  				int i = mc.world.getCombinedLight(new BlockPos(adj), minLight);
+  			
+  				int j = i % 65536;
+  				int k = i / 65536;
+  				
+  				OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, (float)j, (float)k);
+
+  				if(!Config.isShaders()){
+  					float b = ((float)k) / 255;
+  					if (j>k) b = ((float)j) / 255;
+  					GlStateManager.color3f(b, b, b);
+  				}  				
+  			}
+  			
+  			GL11.glPushMatrix();
+  				GL11.glTranslated(crossX , crossY , crossZ );
+  				
+  				if(mc.objectMouseOver == null || mc.objectMouseOver.type == Type.ENTITY ) {
+  					GL11.glRotatef(-mc.vrPlayer.vrdata_world_render.getController(0).getYaw(), 0.0F, 1.0F, 0.0F);
+  					GL11.glRotatef(-mc.vrPlayer.vrdata_world_render.getController(0).getPitch(), 1.0F, 0.0F, 0.0F);
+  				} else {
+  					switch (mc.objectMouseOver.sideHit) {
+  					case DOWN:
+  						GL11.glRotatef(-mc.vrPlayer.vrdata_world_render.getController(0).getYaw(), 0.0F, 1.0F, 0.0F);
+  						GL11.glRotatef(-90, 1.0F, 0.0F, 0.0F);
+  						break;
+  					case EAST:
+  						GL11.glRotatef(90, 0.0F, 1.0F, 0.0F);
+  				//		GL11.glRotatef(0, 1.0F, 0.0F, 0.0F);
+  						break;
+  					case NORTH:
+  					//	GL11.glRotatef(-mc.vrPlayer.vrdata_world_render.getController(0).getYaw(), 0.0F, 1.0F, 0.0F);
+  				//		GL11.glRotatef(0, 1.0F, 0.0F, 0.0F);
+  						break;
+  					case SOUTH:
+  				//		GL11.glRotatef(-mc.vrPlayer.vrdata_world_render.getController(0).getYaw(), 0.0F, 1.0F, 0.0F);
+  				//		GL11.glRotatef(0, 1.0F, 0.0F, 0.0F);
+  						break;
+  					case UP:
+  						GL11.glRotatef(-mc.vrPlayer.vrdata_world_render.getController(0).getYaw(), 0.0F, 1.0F, 0.0F);
+  						GL11.glRotatef(-90, 1.0F, 0.0F, 0.0F);
+  						break;
+  					case WEST:
+  						GL11.glRotatef(90, 0.0F, 1.0F, 0.0F);
+  						//GL11.glRotatef(0, 1.0F, 0.0F, 0.0F);
+  						break;
+  					default:
+  						break;
+  					
+  					}
+  				}
+  					
+  						
+  				if (false)//(this.mc.vrSettings.crosshairRollsWithHead)
+  					GL11.glRotated(0, 0.0F, 0.0F, 1.0F);
+  				
+  				if (this.mc.vrSettings.crosshairScalesWithDistance)
+  				{
+  					float depthscale = .3f + 0.2f * crossDepth;
+  					scale *=(depthscale);
+  				}
+  					
+  				GL11.glScalef(scale, scale, scale);
+  				GlStateManager.depthMask(false);
+  				GlStateManager.disableLighting();
+  				GlStateManager.disableCull();
+  				
+  				if (!this.mc.vrSettings.useCrosshairOcclusion)	
+  					GlStateManager.disableDepthTest();
+  				else
+  					GlStateManager.enableAlphaTest();
+  				
+  				boolean shadersMod = Config.isShaders();
+  								
+  				GlStateManager.disableBlend(); //thats just how it is now.
+
+  				GlStateManager.colorMask(true, true, true, false);
+  				
+  				if (mc.objectMouseOver == null) {
+  					GL11.glRotatef(45, 0, 0, 1);
+  				}
+  				
+  				this.mc.getTextureManager().bindTexture(Gui.ICONS);
+  				
+  				GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL12.GL_CLAMP_TO_EDGE);
+  				GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL12.GL_CLAMP_TO_EDGE);
+  				GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST);
+  				GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_NEAREST);
+  	
+  				float var7 = 0.00390625F;
+  				float var8 = 0.00390625F;
+  				
+  				BufferBuilder b = Tessellator.getInstance().getBuffer();
+  				b.begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_TEX_NORMAL);	
+  	
+  				b.pos(- 1, + 1, 0).tex( 0     , 15* var8).normal(0, 0, -1).endVertex();
+  				b.pos(+ 1, + 1, 0).tex( 15*var7, 15* var8).normal(0, 0, -1).endVertex();
+  				b.pos(+ 1, - 1, 0).tex( 15*var7, 0       ).normal(0, 0, -1).endVertex();
+  				b.pos(- 1, - 1, 0).tex( 0      , 0       ).normal(0, 0, -1).endVertex();		
+  				
+  				Tessellator.getInstance().draw();
+  				
+  		        GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
+  		        
+  				GlStateManager.colorMask(true, true, true, true);
+  				GlStateManager.depthMask(true);
+  				GlStateManager.disableBlend();
+  				GlStateManager.enableDepthTest();
+  				GlStateManager.color4f(1, 1, 1, 1);
+  			GL11.glPopMatrix();
+  		}
+  	
+  	
+  	}
+  	
+  	public void renderFadeBlend(float r, float g, float b,  float fadeAlpha)
+  	{
+  		renderFadeBlend(r, g, b, fadeAlpha, 0, this.mc.displayFBWidth, this.mc.displayFBHeight, 0);
+  	}
+
+  	public Vec3d getControllerRenderPos(int c){
+  		Vec3d out ;
+
+  		if(mc.vrSettings.seated){	
+  			if(mc.getRenderViewEntity() != null && mc.world != null){
+  				Vec3d dir = mc.vrPlayer.vrdata_world_render.hmd.getDirection();
+  				dir = dir.rotateYaw((float) Math.toRadians(c==0?-35:35));
+  				dir = new Vec3d(dir.x, 0, dir.z);
+  				dir = dir.normalize();
+  				renderPass p = renderPass.Center;
+  				out = mc.vrPlayer.vrdata_world_render.getEye(p).getPosition().add(dir.x*0.3 * mc.vrPlayer.vrdata_world_render.worldScale, -0.4* mc.vrPlayer.vrdata_world_render.worldScale ,dir.z*0.3* mc.vrPlayer.vrdata_world_render.worldScale);
+  			} else { //main menu
+  				Vec3d dir = mc.vrPlayer.vrdata_world_render.hmd.getDirection();
+  				dir = dir.rotateYaw((float) Math.toRadians(c==0?-35:35));
+  				dir = new Vec3d(dir.x, 0, dir.z);
+  				dir = dir.normalize();
+  				out = mc.vrPlayer.vrdata_world_render.hmd.getPosition().add(dir.x*0.3 , -0.4 ,dir.z*0.3);
+  			}
+  			return out;
+  		} else {
+  			return mc.vrPlayer.vrdata_world_render.getController(c).getPosition();
+  		}
+  	}
+      
+
+  	
+      private  void applyGUIModelView(renderPass currentPass)
+  	{
+     		mc.profiler.startSection("applyGUIModelView");
+  	
+  			Vec3d eye =mc.vrPlayer.vrdata_world_render.getEye(currentPass).getPosition();
+  			
+  			if(mc.currentScreen != null && GuiHandler.guiPos_room == null){
+  				//naughty mods!
+  				GuiHandler.onGuiScreenChanged(null, mc.currentScreen, false);			
+  			}
+  			
+  			Vec3d guipos = GuiHandler.guiPos_room;
+  			Matrix4f guirot = GuiHandler.guiRotation_room;
+  			Vec3d guiLocal = new Vec3d(0, 0, 0);		
+  			float scale = GuiHandler.guiScale;
+  			
+  			if(guipos == null){
+  				guirot = null;
+  				scale = 1;
+  				if (mc.world!=null && (mc.currentScreen==null || mc.vrSettings.floatInventory == false))
+  				// HUD view - attach to head or controller
+  				{
+  					int i = 1;
+  					if (mc.vrSettings.vrReverseHands) i = -1;
+
+  					//					if(currentPass != renderPass.Third)
+  					//						eye = mc.vrPlayer.getEyePos_World(currentPass); //dont need interpolation.
+  					//					else {
+  					//						mc.getMRTransform(false);
+  					//						eye = mc.vrPlayer.vrdata_world_render.getEye(mc.currentPass).getPosition();
+  					//					}
+  					if (mc.vrSettings.seated || mc.vrSettings.vrHudLockMode == mc.vrSettings.HUD_LOCK_HEAD)
+  					{
+  						Matrix4f rot = Matrix4f.rotationY((float)mc.vrPlayer.vrdata_world_render.rotation);
+  						Matrix4f max = Matrix4f.multiply(rot, MCOpenVR.hmdRotation);
+
+  						Vec3d v = mc.vrPlayer.vrdata_world_render.hmd.getPosition();
+  						Vec3d d = mc.vrPlayer.vrdata_world_render.hmd.getDirection();
+
+  						if(mc.vrSettings.seated && mc.vrSettings.seatedHudAltMode){
+  							d = mc.vrPlayer.vrdata_world_render.getController(0).getDirection();
+  							max = Matrix4f.multiply(rot, MCOpenVR.getAimRotation(0)); 
+  						}
+
+  						guipos = new Vec3d((v.x + d.x*mc.vrPlayer.vrdata_world_render.worldScale), 
+  								(v.y + d.y*mc.vrPlayer.vrdata_world_render.worldScale), 
+  								(v.z + d.z*mc.vrPlayer.vrdata_world_render.worldScale));
+
+
+  						Quatf orientationQuat = OpenVRUtil.convertMatrix4ftoRotationQuat(max);
+
+  						guirot = new Matrix4f(orientationQuat);
+
+  						//float pitchOffset = (float) Math.toRadians( -mc.vrSettings.hudPitchOffset );
+  						//float yawOffset = (float) Math.toRadians( -mc.vrSettings.hudYawOffset );
+  						//guiRotationPose = Matrix4f.multiply(guiRotationPose, OpenVRUtil.rotationXMatrix(yawOffset));
+  						//guiRotationPose = Matrix4f.multiply(guiRotationPose, Matrix4f.rotationY(pitchOffset));
+  						guirot.M[3][3] = 1.0f;
+
+  					}else if (mc.vrSettings.vrHudLockMode == mc.vrSettings.HUD_LOCK_HAND)//hud on hand
+  					{
+  						Matrix4f out = MCOpenVR.getAimRotation(1);
+  						Matrix4f rot = Matrix4f.rotationY((float) mc.vrPlayer.vrdata_world_render.rotation);
+  						Matrix4f MguiRotationPose =  Matrix4f.multiply(rot,out);
+  						//	MguiRotationPose.M[1][3] = 0.5f;
+  						//guiRotationPose = mc.vrPlayer.getControllerMatrix_World(1);
+  						guirot = Matrix4f.multiply(MguiRotationPose, OpenVRUtil.rotationXMatrix((float) Math.PI * -0.2F));
+  						guirot = Matrix4f.multiply(guirot, Matrix4f.rotationY((float) Math.PI * 0.1F * i));
+  						guirot.M[3][3] = 1.7f;
+
+  						guiLocal = new Vec3d(guiLocal.x, 0.5*mc.vrPlayer.vrdata_world_render.worldScale,guiLocal.z);
+
+  						guipos = getControllerRenderPos(1);
+
+  						MCOpenVR.hudPopup = true;
+
+  					}
+  					else if (mc.vrSettings.vrHudLockMode == mc.vrSettings.HUD_LOCK_WRIST)//hud on wrist
+  					{
+
+  						Matrix4f out = MCOpenVR.getAimRotation(1);
+  						Matrix4f rot = Matrix4f.rotationY((float) mc.vrPlayer.vrdata_world_render.rotation);
+  						guirot =  Matrix4f.multiply(rot,out);
+
+  						guirot = Matrix4f.multiply(guirot, Matrix4f.rotationY((float) Math.PI * 0.3f *i));				
+
+  						Vector3f forward = new Vector3f(0,0,1);
+  						Vector3f guiNormal = guirot.transform(forward);
+
+  						Vec3d facev = mc.vrPlayer.vrdata_world_render.hmd.getDirection();
+  						Vector3f face = new Vector3f((float)facev.x, (float)facev.y, (float)facev.z);
+
+  						float dot = face.dot(guiNormal);
+
+  						guipos = getControllerRenderPos(1);
+
+  						Vec3d head = mc.vrPlayer.vrdata_world_render.hmd.getPosition();
+
+  						Vector3f headv = new Vector3f((float)guipos.x, (float)guipos.y, (float)guipos.z).subtract(new Vector3f((float)head.x, (float)head.y, (float)head.z)).normalised();
+  						if(headv == null) return;
+  						float dot2 = (float) headv.dot(guiNormal);
+
+  						if(MCOpenVR.hudPopup){
+  							MCOpenVR.hudPopup = Math.abs(dot2) > 0.5 &&  dot < -0.7;
+  						}else {
+  							MCOpenVR.hudPopup = Math.abs(dot2) > 0.9 &&  dot < -0.97;	
+  						}
+
+  						if(MCOpenVR.hudPopup){
+  							scale = .5f;
+  							guiLocal = new Vec3d(
+  									-0.005*mc.vrPlayer.vrdata_world_render.worldScale,
+  									0.16*mc.vrPlayer.vrdata_world_render.worldScale,
+  									0.19*mc.vrPlayer.vrdata_world_render.worldScale);
+  						}else {
+  							scale = 0.33f;
+  							guiLocal = new Vec3d(
+  									i*-0.12f*mc.vrPlayer.vrdata_world_render.worldScale,
+  									0.1*mc.vrPlayer.vrdata_world_render.worldScale,
+  									0.06*mc.vrPlayer.vrdata_world_render.worldScale);
+  							guirot = Matrix4f.multiply(guirot, Matrix4f.rotationY((float) Math.PI * 0.2f*i ));		
+  						}
+  					}
+  				} 
+  			} else {
+  				//convert previously calculated coords to world coords
+  				guipos = mc.vrPlayer.room_to_world_pos(guipos, mc.vrPlayer.vrdata_world_render); 
+  				Matrix4f rot = Matrix4f.rotationY(mc.vrPlayer.vrdata_world_render.rotation);
+  				guirot = Matrix4f.multiply(rot, guirot);
+  			}
+  			
+  			
+  			// otherwise, looking at inventory screen. use pose calculated when screen was opened
+  			//where is this set up... should be here....
+  			
+  			if (((mc.vrSettings.seated || mc.vrSettings.menuAlwaysFollowFace) && (mc.world == null || mc.currentScreen instanceof GuiWinGame))){ //|| mc.vrSettings.vrHudLockMode == VRSettings.HUD_LOCK_BODY) {
+  				
+  				//main menu slow yaw tracking thing
+  				scale = 2;
+  				
+  				Vec3d posAvg = new Vec3d(0, 0, 0);
+  				for (Vec3d vec : mc.hmdPosSamples) {
+  					posAvg = new Vec3d(posAvg.x + vec.x, posAvg.y + vec.y, posAvg.z + vec.z);
+  				}
+  				posAvg = new Vec3d(posAvg.x / mc.hmdPosSamples.size(), posAvg.y / mc.hmdPosSamples.size(), posAvg.z / mc.hmdPosSamples.size());
+  				
+  				float yawAvg = 0;
+  				for (float f : mc.hmdYawSamples) {
+  					yawAvg += f;
+  				}
+  				yawAvg /= mc.hmdYawSamples.size();
+  				yawAvg = (float)Math.toRadians(yawAvg);
+  							
+  				Vec3d dir = new Vec3d(-Math.sin(yawAvg), 0, Math.cos(yawAvg));
+  				float dist = mc.world == null || mc.currentScreen instanceof GuiWinGame ? 2.5F*mc.vrPlayer.vrdata_world_render.worldScale: mc.vrSettings.hudDistance;
+  				Vec3d pos = posAvg.add(new Vec3d(dir.x * dist, dir.y * dist, dir.z * dist));
+  				Vec3d gpr = new Vec3d(pos.x, pos.y, pos.z);
+  				
+  				Matrix4f gr = Matrix4f.rotationY(135-yawAvg); // don't ask
+  				
+  				guirot = Matrix4f.multiply(gr, Matrix4f.rotationY(mc.vrPlayer.vrdata_world_render.rotation));
+  				guipos = mc.vrPlayer.room_to_world_pos(gpr, mc.vrPlayer.vrdata_world_render); 
+  				
+  				//for mouse control
+  				GuiHandler.guiRotation_room = gr;
+  				GuiHandler.guiScale=2;
+  				GuiHandler.guiPos_room = gpr;
+  				//
+  			}
+  			
+  			// counter head rotation
+  			if (currentPass != renderPass.Third) {
+  				GL11.glMultMatrix(mc.vrPlayer.vrdata_world_render.hmd.getMatrix().toFloatBuffer());
+  			} else {
+  				applyMRCameraRotation(false);			
+  			}
+
+  			
+  			GL11.glTranslatef((float) (guipos.x - eye.x), (float)(guipos.y - eye.y), (float)(guipos.z - eye.z));
+//  		
+//  			// offset from eye to gui pos
+  			GL11.glMultMatrix(guirot.transposed().toFloatBuffer());
+  			GL11.glTranslatef((float)guiLocal.x, (float) guiLocal.y, (float)guiLocal.z);
+  		
+  			float thescale = scale * mc.vrPlayer.vrdata_world_render.worldScale; // * this.mc.vroptions.hudscale
+  			GlStateManager.scale(thescale, thescale, thescale);
+
+  			int minLight = Config.isShaders() ? 8 : 4; 
+  			if(mc.world != null){
+  				if (itemRenderer.isInsideOpaqueBlock(guipos, false))
+  					guipos = mc.vrPlayer.vrdata_world_render.hmd.getPosition();
+  				
+  				int i = mc.world.getCombinedLight(new BlockPos(guipos), minLight);
+  				int j = i % 65536;
+  				int k = i / 65536;
+  				OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, (float)j, (float)k);
+
+  				if(!Config.isShaders()){ 
+  					float b = ((float)k) / 255;
+  					if (j>k) b = ((float)j) / 255;
+  					GlStateManager.color(b, b, b); // \_(oo)_/
+  				}  
+  				
+  			}
+  				//double timeOpen = getCurrentTimeSecs() - startedOpeningInventory;
+  	
+  	
+  				//		if (timeOpen < 1.5) {
+  				//			scale = (float)(Math.sin(Math.PI*0.5*timeOpen/1.5));
+  				//		}
+  	
+  			mc.mcProfiler.endSection();
+  	
+  	} 
+      
+      
+      private  void apply2DModelView(renderPass currentPass, Vec3d guipos, Matrix4f guirot)
+    	{
+       		mc.profiler.startSection("applyKeyboardModelView");
+    	
+    			Vec3d eye =mc.vrPlayer.vrdata_world_render.getEye(currentPass).getPosition();
+    			
+    			Vec3d guiLocal = new Vec3d(0, 0, 0);	
+    			
+    			float scale = GuiHandler.guiScale;			
+
+    			//convert previously calculated coords to world coords
+    			guipos = mc.vrPlayer.room_to_world_pos(guipos, mc.vrPlayer.vrdata_world_render); 
+    			Matrix4f rot = Matrix4f.rotationY(mc.vrPlayer.vrdata_world_render.rotation);
+    			guirot = Matrix4f.multiply(rot, guirot);
+
+   	  			
+    			// counter head rotation
+    			if (currentPass != renderPass.Third) {
+    				GL11.glMultMatrix(mc.vrPlayer.vrdata_world_render.hmd.getMatrix().toFloatBuffer());
+    			} else {
+    				applyMRCameraRotation(false);			
+    			}
+
+    			
+    			GL11.glTranslatef((float) (guipos.x - eye.x), (float)(guipos.y - eye.y), (float)(guipos.z - eye.z));
+//    		
+//    			// offset from eye to gui pos
+    			GL11.glMultMatrix(guirot.transposed().toFloatBuffer());
+    			GL11.glTranslatef((float)guiLocal.x, (float) guiLocal.y, (float)guiLocal.z);
+    		
+    			float thescale = scale * mc.vrPlayer.vrdata_world_render.worldScale; // * this.mc.vroptions.hudscale
+    			GlStateManager.scale(thescale, thescale, thescale);
+
+    			int minLight = Config.isShaders() ? 8 : 4; 
+    			if(mc.world != null){
+    				if (itemRenderer.isInsideOpaqueBlock(guipos, false))
+    					guipos = mc.vrPlayer.vrdata_world_render.hmd.getPosition();
+    				
+    				int i = mc.world.getCombinedLight(new BlockPos(guipos), minLight);
+    				int j = i % 65536;
+    				int k = i / 65536;
+    				OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, (float)j, (float)k);
+
+    				if(!Config.isShaders()){ 
+    					float b = ((float)k) / 255;
+    					if (j>k) b = ((float)j) / 255;
+    					GlStateManager.color(b, b, b); // \_(oo)_/
+    				}  			
+    			}
+
+    			mc.mcProfiler.endSection();
+    	
+    	} 
+      
+  	private void applyMenuRoomModelView(renderPass currentPass)
+  	{
+  		Vec3d eye = mc.vrPlayer.vrdata_world_render.getEye(mc.currentPass).getPosition();
+  		
+  		// counter head rotation
+  		if (currentPass != renderPass.Third) {
+  				GL11.glMultMatrixf(mc.vrPlayer.vrdata_world_render.hmd.getMatrix().toFloatBuffer());
+  		} else {
+  			applyMRCameraRotation(false);		}
+
+  		GL11.glTranslatef((float)(mc.vrPlayer.vrdata_world_render.origin.x - eye.x), (float)(mc.vrPlayer.vrdata_world_render.origin.y - eye.y), (float)(mc.vrPlayer.vrdata_world_render.origin.z - eye.z));
+  	}
+           
+  	private void setupPolyRendering(boolean enable){
+  		boolean shadersMod = Config.isShaders();
+  		boolean shadersModShadowPass = false;
+  		if(enable){
+  			polyblendsrc = GlStateManager.BLEND.srcFactor;
+  			polyblenddst = GlStateManager.BLEND.dstFactor;
+  			polyblend = GL11.glIsEnabled(GL11.GL_BLEND);
+  			polytex =  GL11.glIsEnabled(GL11.GL_TEXTURE_2D);
+  			polylight =  GL11.glIsEnabled(GL11.GL_LIGHTING);
+  			polycull =  GL11.glIsEnabled(GL11.GL_CULL_FACE);
+
+  			GlStateManager.enableBlend();
+  			GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
+  			GlStateManager.disableTexture2D();
+  			GlStateManager.disableLighting();
+  			GlStateManager.disableCull();
+  			if(shadersMod){
+  				prog  = Shaders.activeProgram;
+  				Shaders.useProgram(Shaders.ProgramNone);
+  			}
+  		} else {
+  			GlStateManager.blendFunc(polyblendsrc, polyblenddst);
+  			if (!polyblend) GlStateManager.disableBlend(); 
+  			if (polytex) GlStateManager.enableTexture2D();
+  			if (polylight) GlStateManager.enableLighting();
+  			if (polycull) GlStateManager.enableCull();
+  			if(shadersMod && polytex)
+  				Shaders.useProgram(prog);
+  		}
+  	}
+       	
+  	public void setupRVE() {
+  		if (!cached) 
+  			return;
+  		
+  		Vec3d f;
+  		if(mc.currentPass == renderPass.Third){
+  			f = mc.vrPlayer.vrdata_world_render.getEye(renderPass.Third).getPosition();
+  		}
+  		else{
+  			f = mc.vrPlayer.vrdata_world_render.getEye(renderPass.Center).getPosition();
+  		}
+  		
+      	EntityLivingBase rve = (EntityLivingBase) this.mc.getRenderViewEntity();
+
+  		rve.posX = f.x;
+  		rve.posY = f.y;
+  		rve.posZ = f.z;
+  		rve.lastTickPosX = f.x;
+  		rve.lastTickPosY = f.y;
+  		rve.lastTickPosZ = f.z;
+  		rve.prevPosX = f.x;
+  		rve.prevPosY = f.y;
+  		rve.prevPosZ = f.z;
+  		rve.rotationPitch =rve.prevRotationPitch = -mc.vrPlayer.vrdata_world_render.hmd.getPitch();
+  		rve.prevRotationYawHead	= rve.prevRotationYaw  = rve.rotationYaw = rve.rotationYawHead = mc.vrPlayer.vrdata_world_render.hmd.getYaw();
+  		rve.height = 0;
+  		if(rve instanceof EntityPlayerSP)
+  			((EntityPlayerSP)rve).overrideEyeHeight = true;
+  	}	
+  	
+  	public void cacheRVEPos(EntityLivingBase e){
+  		if (mc.getRenderViewEntity() == null) return;
+  		if (cached) 
+  			return;
+  		rveX = e.posX;
+  		rveY = e.posY;
+  		rveZ = e.posZ;
+  		rvelastX = e.lastTickPosX;
+  		rvelastY = e.lastTickPosY;
+  		rvelastZ = e.lastTickPosZ;
+  		rveprevX = e.prevPosX;
+  		rveprevY = e.prevPosY;
+  		rveprevZ = e.prevPosZ;	
+  		rveyaw = e.rotationYawHead;
+  		rvepitch = e.rotationPitch;
+  		rvelastyaw = e.prevRotationYawHead;
+  		rvelastpitch = e.prevRotationPitch;
+  		rveHeight = e.height;
+  		cached = true;
+  	}
+  	
+  	public void restoreRVEPos(EntityLivingBase e){
+  		if (e == null) return;
+  		e.posX = rveX;
+  		e.posY = rveY;
+  		e.posZ = rveZ;
+  		e.lastTickPosX = rvelastX;
+  		e.lastTickPosY = rvelastY;
+  		e.lastTickPosZ = rvelastZ;
+  		e.prevPosX = rveprevX;
+  		e.prevPosY = rveprevY;
+  		e.prevPosZ = rveprevZ;
+  		e.rotationYaw = rveyaw;
+  		e.rotationPitch = rvepitch;
+  		e.prevRotationYaw = rvelastyaw;
+  		e.prevRotationPitch = rvelastpitch;
+  		e.rotationYawHead = rveyaw;
+  		e.prevRotationYawHead = rvelastyaw;
+  		e.height = rveHeight;
+  		if(e instanceof EntityPlayerSP)
+  			((EntityPlayerSP)e).overrideEyeHeight = false;
+
+  		cached = false;
+  	}
+  	
+  	private Vec3d getRVEPositionEyes(float partialTicks) {
+  		if (mc.getRenderViewEntity() == null) return new Vec3d(0, 0, 0);
+  		if (cached) {
+  			if (partialTicks == 1.0F) {
+  				return new Vec3d(rveX, rveY + mc.getRenderViewEntity().getEyeHeight(), rveZ);
+  			} else {
+  				double d0 = rveprevX + (rveX - rveprevX) * partialTicks;
+  				double d1 = rveprevY + (rveY - rveprevY) * partialTicks + mc.getRenderViewEntity().getEyeHeight();
+  				double d2 = rveprevZ + (rveZ - rveprevZ) * partialTicks;
+  				return new Vec3d(d0, d1, d2);
+  			}
+  		} else {
+  			return mc.getRenderViewEntity().getPositionEyes(partialTicks);
+  		}
+  	}
+  	
+  private void renderFaceOverlay(float par1){ //replaced with shader
+  	boolean shadersMod = Config.isShaders();
+  	if (shadersMod) {
+  		//just disables caps
+  		Shaders.beginFPOverlay();
+  	}
+  	
+  	this.itemRenderer.renderOverlays(par1);
+  	
+  	if (shadersMod) {
+  		//does nothing at all.
+  		Shaders.endFPOverlay();
+  	}
+  }
+  	
+  	private void renderVRThings(float par1){
+
+  		if (this.mc.gameSettings.thirdPersonView == 0)
+  		{
+  			GL11.glMatrixMode(GL11.GL_MODELVIEW);
+  			GL11.glLoadIdentity();
+
+  			renderItemActivation(0, 0, par1); //totem of undying
+  			
+  			GlStateManager.disableCull();
+  			
+  			AxisAlignedBB bb = mc.player.getEntityBoundingBox();
+  			if(this.mc.vrSettings.vrShowBlueCircleBuddy && bb != null){ 	//blue circle buddy	  - have to draw here so it sits on top of overlays (face in block)
+  				GL11.glMatrixMode(GL11.GL_PROJECTION);
+  				GL11.glPushMatrix();
+  				GL11.glMatrixMode(GL11.GL_MODELVIEW);
+  				GL11.glPushMatrix();
+  				GlStateManager.loadIdentity();
+  				
+  					setupCameraTransform(par1, 0);
+  					applyCameraDepth(false);
+  	
+  					Vec3d o = mc.vrPlayer.vrdata_world_render.getEye(renderPass.Center).getPosition();
+  					if (mc.currentPass == renderPass.Third) 
+  						o=mc.vrPlayer.vrdata_world_render.getEye(renderPass.Third).getPosition();
+  	
+  					EntityPlayerSP player = mc.player;
+  					
+  			    	Vec3d interpolatedPlayerPos = new Vec3d(
+  			    			rvelastX + (rveX - rvelastX) * (double)par1,
+  			    			rvelastY + (rveY - rvelastY) * (double)par1,
+  			    			rvelastZ + (rveZ - rvelastZ) * (double)par1
+  			    			);
+  							    		    	
+  					Vec3d pos = interpolatedPlayerPos.subtract(o).addVector(0, 0.005, 0);
+  					setupPolyRendering(true);
+  					GlStateManager.blendFunc(SourceFactor.ZERO, DestFactor.ONE_MINUS_SRC_ALPHA);
+  					GlStateManager.disableDepth();
+  					renderFlatQuad(pos,
+  							(float)(bb.maxX - bb.minX),
+  							(float) (bb.maxZ - bb.minZ),
+  							0, 0, 255, 255, 64);
+  					GlStateManager.enableDepth();
+  					setupPolyRendering(false);
+  						
+  				GL11.glMatrixMode(GL11.GL_PROJECTION);
+  				GL11.glPopMatrix();
+  				GL11.glMatrixMode(GL11.GL_MODELVIEW);
+  				GL11.glPopMatrix();
+  			}
+  		}
+  		
+  		
+  		if(mc.currentPass == renderPass.Left || mc.currentPass == renderPass.Right){
+  			if(mc.vrSettings.displayMirrorMode == mc.vrSettings.MIRROR_MIXED_REALITY || mc.vrSettings.displayMirrorMode == VRSettings.MIRROR_THIRD_PERSON) {
+
+  				//render the camera
+  				GL11.glMatrixMode(GL11.GL_PROJECTION);
+  				GL11.glPushMatrix();
+  				GL11.glMatrixMode(GL11.GL_MODELVIEW);
+  				GL11.glPushMatrix();
+
+  				setupCameraTransform(par1, 0);
+  				applyCameraDepth(false);
+
+  				Vec3d cam = mc.vrPlayer.vrdata_world_render.getEye(renderPass.Third).getPosition();
+  				Vec3d o = mc.vrPlayer.vrdata_world_render.getEye(renderPass.Center).getPosition();
+  				Vec3d pos = cam.subtract(o);
+
+  				GL11.glTranslated(pos.x, pos.y, pos.z);	
+  				applyMRCameraRotation(true);
+  				GL11.glRotated(180, 0, 1, 0);
+  				renderDebugAxes(0, 0, 0, 0.08f * mc.vrPlayer.vrdata_world_render.worldScale); //TODO: camera model?
+
+  				GL11.glTranslatef(0, 0.125f, 0);
+  				
+  				mc.framebufferMR.bindFramebufferTexture();
+  				drawSizedQuad(320, 200, 0.25f);
+  				
+  				GL11.glMatrixMode(GL11.GL_PROJECTION);
+  				GL11.glPopMatrix();
+  				GL11.glMatrixMode(GL11.GL_MODELVIEW);
+  				GL11.glPopMatrix();
+  			}
+  		}
+  			
+  	}
+  	
+  	public void applyMRCameraRotation(boolean invert){
+  			com.mtbs3d.minecrift.utils.LWJGL.Matrix4f view = new com.mtbs3d.minecrift.utils.LWJGL.Matrix4f(mc.thirdPassViewMatrix);
+  			view.m30 = 0;
+  			view.m31 = 0;
+  			view.m32 = 0;
+  			if(!invert) view = (org.lwjgl.util.vector.Matrix4f) view.invert(); //yea yea i know.
+  			view.store(matrixBuffer);
+  			matrixBuffer.rewind();
+  			GlStateManager.multMatrix(matrixBuffer);
+  			matrixBuffer.rewind();
+  	}
+  	
+  	private void renderViveHudIcons(){
+          //VIVE SPRINTDICATOR
+          if (this.mc.getRenderViewEntity() instanceof EntityPlayer)
+          {
+              ScaledResolution scaledresolution = new ScaledResolution(this.mc);
+              int i = scaledresolution.getScaledWidth();
+              int j = scaledresolution.getScaledHeight();
+              FontRenderer fontrenderer = mc.ingameGUI.getFontRenderer();
+              this.mc.entityRenderer.setupOverlayRendering();
+          	EntityPlayer entityplayer = (EntityPlayer)this.mc.getRenderViewEntity();
+          	int iconp = 0;
+          	if(entityplayer.isSprinting()) iconp = 10;
+          	if(entityplayer.isSneaking()) iconp = 13;
+          	if(entityplayer.isElytraFlying()) iconp = -1;
+          	if(iconp!=0){
+          		GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
+
+          		if(iconp ==-1){
+              		int w = scaledresolution.getScaledWidth() / 2 - 109;
+              		int h = scaledresolution.getScaledHeight() -39;
+                      TextureAtlasSprite textureatlassprite = this.mc.getTextureMapBlocks().getAtlasSprite("minecraft:items/elytra");
+                      this.mc.getTextureManager().bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
+                      mc.ingameGUI.drawTexturedModalRect(w, h, textureatlassprite, 16, 16);
+          		}else{
+          			this.mc.getTextureManager().bindTexture(mc.ingameGUI.INVENTORY_BACKGROUND);
+              		int w = scaledresolution.getScaledWidth() / 2 - 109;
+              		int h = scaledresolution.getScaledHeight() -39;
+              		mc.ingameGUI.drawTexturedModalRect(w, h, 0 + iconp % 8 * 18, 198 + iconp / 8 * 18, 18, 18);        			
+          		}
+          	}
+          }
+          //
+  	}
+
+  	
+  	public static void drawText(FontRenderer fontRendererIn, String str, float x, float y, float z, float viewerYaw, float viewerPitch)
+  	{
+  		GlStateManager.pushMatrix();
+  		GlStateManager.translatef(x, y, z);
+  		GlStateManager.normal3f(0.0F, 1.0F, 0.0F);
+  		GlStateManager.rotatef(-viewerYaw, 0.0F, 1.0F, 0.0F);
+  		GlStateManager.rotatef((float) viewerPitch, 1.0F, 0.0F, 0.0F);
+  		GlStateManager.scalef(-0.025F, -0.025F, 0.025F);
+  		GlStateManager.disableLighting();
+  		GlStateManager.depthMask(false);
+
+  		GlStateManager.disableDepthTest();
+
+  		GlStateManager.enableBlend();
+  		GlStateManager.blendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
+  		int i = fontRendererIn.getStringWidth(str) / 2;
+  		GlStateManager.disableTexture2D();
+  		Tessellator tessellator = Tessellator.getInstance();
+  		BufferBuilder bufferbuilder = tessellator.getBuffer();
+  		bufferbuilder.begin(7, DefaultVertexFormats.POSITION_COLOR);
+  		bufferbuilder.pos((double)(-i - 1), (double)(-1 ), 0.0D).color(0.0F, 0.0F, 0.0F, 0.25F).endVertex();
+  		bufferbuilder.pos((double)(-i - 1), (double)(8 ), 0.0D).color(0.0F, 0.0F, 0.0F, 0.25F).endVertex();
+  		bufferbuilder.pos((double)(i + 1), (double)(8 ), 0.0D).color(0.0F, 0.0F, 0.0F, 0.25F).endVertex();
+  		bufferbuilder.pos((double)(i + 1), (double)(-1 ), 0.0D).color(0.0F, 0.0F, 0.0F, 0.25F).endVertex();
+  		tessellator.draw();
+  		GlStateManager.enableTexture2D();
+
+  		if (true)
+  		{
+  			fontRendererIn.drawString(str, -fontRendererIn.getStringWidth(str) / 2, 0, 553648127);
+  			GlStateManager.enableDepthTest();
+  		}
+
+  		GlStateManager.depthMask(true);
+  		fontRendererIn.drawString(str, -fontRendererIn.getStringWidth(str) / 2, 0, -1);
+  		GlStateManager.enableLighting();
+  		GlStateManager.disableBlend();
+  		GlStateManager.color4f(1.0F, 1.0F, 1.0F, 1.0F);
+  		GlStateManager.popMatrix();
+  	}
+
+  	// VIVE END - render functions
+
 }
