--- a/net/minecraft/client/renderer/FirstPersonRenderer.java
+++ b/net/minecraft/client/renderer/FirstPersonRenderer.java
@@ -3,10 +3,25 @@
 import com.google.common.base.MoreObjects;
 import com.mojang.blaze3d.platform.GLX;
 import com.mojang.blaze3d.platform.GlStateManager;
+
+import java.util.HashMap;
+import java.util.Map;
 import java.util.Objects;
+
+import org.lwjgl.opengl.GL11;
+import org.vivecraft.control.ControllerType;
+import org.vivecraft.gameplay.trackers.BowTracker;
+import org.vivecraft.gameplay.trackers.SwingTracker;
+import org.vivecraft.provider.MCOpenVR;
+import org.vivecraft.render.RenderPass;
+import org.vivecraft.render.RenderVRPlayer;
+
+import net.minecraft.block.BambooBlock;
 import net.minecraft.block.Block;
 import net.minecraft.block.BlockRenderType;
 import net.minecraft.block.BlockState;
+import net.minecraft.block.Blocks;
+import net.minecraft.block.TorchBlock;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.entity.player.AbstractClientPlayerEntity;
 import net.minecraft.client.entity.player.ClientPlayerEntity;
@@ -18,20 +33,37 @@
 import net.minecraft.client.renderer.texture.AtlasTexture;
 import net.minecraft.client.renderer.texture.TextureAtlasSprite;
 import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
+import net.minecraft.enchantment.EnchantmentHelper;
 import net.minecraft.entity.LivingEntity;
 import net.minecraft.entity.player.PlayerEntity;
+import net.minecraft.item.AbstractMapItem;
+import net.minecraft.item.ArrowItem;
+import net.minecraft.item.BlockItem;
+import net.minecraft.item.CarrotOnAStickItem;
 import net.minecraft.item.CrossbowItem;
 import net.minecraft.item.FilledMapItem;
+import net.minecraft.item.FishingRodItem;
+import net.minecraft.item.FlintAndSteelItem;
+import net.minecraft.item.HoeItem;
 import net.minecraft.item.Item;
 import net.minecraft.item.ItemStack;
 import net.minecraft.item.Items;
+import net.minecraft.item.MapItem;
+import net.minecraft.item.ShearsItem;
+import net.minecraft.item.ShieldItem;
+import net.minecraft.item.SwordItem;
+import net.minecraft.item.ToolItem;
+import net.minecraft.item.TridentItem;
+import net.minecraft.item.UseAction;
 import net.minecraft.tags.FluidTags;
 import net.minecraft.util.BlockRenderLayer;
 import net.minecraft.util.Hand;
 import net.minecraft.util.HandSide;
 import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.Util;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.MathHelper;
+import net.minecraft.util.math.Vec3d;
 import net.minecraft.world.storage.MapData;
 import net.optifine.Config;
 import net.optifine.DynamicLights;
@@ -51,12 +83,20 @@
     private float prevEquippedProgressOffHand;
     private final EntityRendererManager renderManager;
     private final ItemRenderer itemRenderer;
-
+    //Vivecraft
+    private final RenderVRPlayer myRenderVRPlayer;
+    private final Map<String, RenderVRPlayer> renderVRPlayerSkinMap = new HashMap<>();
+    //
     public FirstPersonRenderer(Minecraft p_i151_1_)
     {
         this.mc = p_i151_1_;
         this.renderManager = p_i151_1_.getRenderManager();
         this.itemRenderer = p_i151_1_.getItemRenderer();
+        //Vivecraft
+        myRenderVRPlayer = new RenderVRPlayer(this.renderManager);
+        renderVRPlayerSkinMap.put("default", this.myRenderVRPlayer);
+        renderVRPlayerSkinMap.put("slim", new RenderVRPlayer(this.renderManager, true));
+        //
     }
 
     public void renderItem(LivingEntity entityIn, ItemStack heldStack, ItemCameraTransforms.TransformType transform)
@@ -101,7 +141,7 @@
         GlStateManager.popMatrix();
     }
 
-    private void setLightmap()
+    public void setLightmap()
     {
         AbstractClientPlayerEntity abstractclientplayerentity = this.mc.player;
         int i = this.mc.world.getCombinedLight(new BlockPos(abstractclientplayerentity.posX, abstractclientplayerentity.posY + (double)abstractclientplayerentity.getEyeHeight(), abstractclientplayerentity.posZ), 0);
@@ -176,29 +216,19 @@
 
     private void renderMapFirstPersonSide(float equippedProgress, HandSide hand, float swingProgress, ItemStack stack)
     {
-        float f = hand == HandSide.RIGHT ? 1.0F : -1.0F;
-        GlStateManager.translatef(f * 0.125F, -0.125F, 0.0F);
-
-        if (!this.mc.player.isInvisible())
-        {
-            GlStateManager.pushMatrix();
-            GlStateManager.rotatef(f * 10.0F, 0.0F, 0.0F, 1.0F);
-            this.renderArmFirstPerson(equippedProgress, swingProgress, hand);
-            GlStateManager.popMatrix();
-        }
-
-        GlStateManager.pushMatrix();
-        GlStateManager.translatef(f * 0.51F, -0.08F + equippedProgress * -1.2F, -0.75F);
-        float f1 = MathHelper.sqrt(swingProgress);
-        float f2 = MathHelper.sin(f1 * (float)Math.PI);
-        float f3 = -0.5F * f2;
-        float f4 = 0.4F * MathHelper.sin(f1 * ((float)Math.PI * 2F));
-        float f5 = -0.3F * MathHelper.sin(swingProgress * (float)Math.PI);
-        GlStateManager.translatef(f * f3, f4 - 0.3F * f2, f5);
-        GlStateManager.rotatef(f2 * -45.0F, 1.0F, 0.0F, 0.0F);
-        GlStateManager.rotatef(f * f2 * -30.0F, 0.0F, 1.0F, 0.0F);
-        this.renderMapFirstPerson(stack);
-        GlStateManager.popMatrix();
+    	float f = hand == HandSide.RIGHT ? 1.0F : -1.0F;
+    	GlStateManager.pushMatrix();
+    	GlStateManager.translatef(-f * 0.125F, -0.125F, 0.0F);
+    	GlStateManager.translatef(-f * 0F, 0.225F, -0.2F);
+    	GlStateManager.rotatef(-30.0F, 1.0F, 0.0F, 0.0F);
+    	GlStateManager.rotatef(-30.0F*f, 0.0F, 1.0F, 0.0F);
+    	float f1 = MathHelper.sqrt(swingProgress);
+    	float f2 = MathHelper.sin(f1 * (float)Math.PI);
+    	float f3 = -0.5F * f2;
+    	float f4 = 0.4F * MathHelper.sin(f1 * ((float)Math.PI * 2F));
+    	float f5 = -0.3F * MathHelper.sin(swingProgress * (float)Math.PI);
+    	this.renderMapFirstPerson(stack);
+    	GlStateManager.popMatrix();
     }
 
     private void renderMapFirstPerson(float pitch, float equippedProgress, float swingProgress)
@@ -206,19 +236,26 @@
         float f = MathHelper.sqrt(swingProgress);
         float f1 = -0.2F * MathHelper.sin(swingProgress * (float)Math.PI);
         float f2 = -0.4F * MathHelper.sin(f * (float)Math.PI);
-        GlStateManager.translatef(0.0F, -f1 / 2.0F, f2);
+        //GlStateManager.translatef(0.0F, -f1 / 2.0F, f2);
         float f3 = this.getMapAngleFromPitch(pitch);
-        GlStateManager.translatef(0.0F, 0.04F + equippedProgress * -1.2F + f3 * -0.5F, -0.72F);
-        GlStateManager.rotatef(f3 * -85.0F, 1.0F, 0.0F, 0.0F);
-        this.renderArms();
+        //GlStateManager.translatef(0.0F, 0.04F + equippedProgress * -1.2F + f3 * -0.5F, -0.72F);
+        //GlStateManager.rotatef(f3 * -85.0F, 1.0F, 0.0F, 0.0F);
+        //this.renderArms();
         float f4 = MathHelper.sin(f * (float)Math.PI);
-        GlStateManager.rotatef(f4 * 20.0F, 1.0F, 0.0F, 0.0F);
-        GlStateManager.scalef(2.0F, 2.0F, 2.0F);
+
+        GlStateManager.translatef(-f * 0F, 0.225F, -0.5F);
+        GlStateManager.scalef(1.5F, 1.5F, 1.5F);
+        GlStateManager.rotatef(-30.0F, 1.0F, 0.0F, 0.0F);
+        GlStateManager.rotatef(-30.0F*f, 0.0F, 1.0F, 0.0F);
+        
+        //GlStateManager.rotatef(f4 * 20.0F, 1.0F, 0.0F, 0.0F);
+        //GlStateManager.scalef(2.0F, 2.0F, 2.0F);
         this.renderMapFirstPerson(this.itemStackMainHand);
     }
 
     private void renderMapFirstPerson(ItemStack stack)
     {
+    	GlStateManager.disableCull();
         GlStateManager.rotatef(180.0F, 0.0F, 1.0F, 0.0F);
         GlStateManager.rotatef(180.0F, 0.0F, 0.0F, 1.0F);
         GlStateManager.scalef(0.38F, 0.38F, 0.38F);
@@ -242,12 +279,14 @@
         }
 
         GlStateManager.enableLighting();
+    	GlStateManager.enableCull();
     }
 
     private void renderArmFirstPerson(float equippedProgress, float swingProgress, HandSide side)
     {
         boolean flag = side != HandSide.LEFT;
         float f = flag ? 1.0F : -1.0F;
+        /*Vivecraft
         float f1 = MathHelper.sqrt(swingProgress);
         float f2 = -0.3F * MathHelper.sin(f1 * (float)Math.PI);
         float f3 = 0.4F * MathHelper.sin(f1 * ((float)Math.PI * 2F));
@@ -258,8 +297,10 @@
         float f6 = MathHelper.sin(f1 * (float)Math.PI);
         GlStateManager.rotatef(f * f6 * 70.0F, 0.0F, 1.0F, 0.0F);
         GlStateManager.rotatef(f * f5 * -20.0F, 0.0F, 0.0F, 1.0F);
+        */
         AbstractClientPlayerEntity abstractclientplayerentity = this.mc.player;
         this.mc.getTextureManager().bindTexture(abstractclientplayerentity.getLocationSkin());
+        /*
         GlStateManager.translatef(f * -1.0F, 3.6F, 3.5F);
         GlStateManager.rotatef(f * 120.0F, 0.0F, 0.0F, 1.0F);
         GlStateManager.rotatef(200.0F, 1.0F, 0.0F, 0.0F);
@@ -278,6 +319,31 @@
         }
 
         GlStateManager.enableCull();
+        */
+        
+        GlStateManager.pushMatrix();
+        
+			this.transformFirstPerson(side, swingProgress);
+        
+        	GlStateManager.scalef(0.4f, 0.4F, 0.4F);
+        	boolean slim = abstractclientplayerentity.getSkinType().equals("slim");
+        	GlStateManager.translatef(slim ? 0.345F * -f : 0.375F * -f, 0, slim ? 0.785F : 0.75F);
+	        GlStateManager.rotatef(-90, 1, 0,0);
+	        
+	        GlStateManager.rotatef(180, 0, 1, 0);	
+
+        	RenderVRPlayer renderVRPlayer = renderVRPlayerSkinMap.get(abstractclientplayerentity.getSkinType());
+        	if (renderVRPlayer == null) renderVRPlayer = myRenderVRPlayer;
+	        if (flag)
+	        {
+	        	renderVRPlayer.renderRightArm(abstractclientplayerentity);
+	        }
+	        else
+	        {
+	        	renderVRPlayer.renderLeftArm(abstractclientplayerentity);
+	        }
+	        
+        GlStateManager.popMatrix();
     }
 
     private void transformEatFirstPerson(float partialTicks, HandSide hand, ItemStack stack)
@@ -288,32 +354,46 @@
         if (f1 < 0.8F)
         {
             float f2 = MathHelper.abs(MathHelper.cos(f / 4.0F * (float)Math.PI) * 0.1F);
-            GlStateManager.translatef(0.0F, f2, 0.0F);
+      //      GlStateManager.translate(0.0F, f2, 0.0F);
         }
 
+	    if(!Minecraft.getInstance().autoFood.isEating()) {
         float f3 = 1.0F - (float)Math.pow((double)f1, 27.0D);
-        int i = hand == HandSide.RIGHT ? 1 : -1;
-        GlStateManager.translatef(f3 * 0.6F * (float)i, f3 * -0.5F, f3 * 0.0F);
+		    int i = hand == HandSide.RIGHT ? 1 : -1;
+		    //  GlStateManager.translate(f3 * 0.6F * (float)i, f3 * -0.5F, f3 * 0.0F);
         GlStateManager.rotatef((float)i * f3 * 90.0F, 0.0F, 1.0F, 0.0F);
         GlStateManager.rotatef(f3 * 10.0F, 1.0F, 0.0F, 0.0F);
         GlStateManager.rotatef((float)i * f3 * 30.0F, 0.0F, 0.0F, 1.0F);
+	    } else { //OM NOM NOM NOM
+			long t = this.mc.player.getItemInUseCount();
+			GlStateManager.translated(0D,0.006D*Math.sin(t), 0D);
+	    }
     }
 
     private void transformFirstPerson(HandSide hand, float swingProgress)
     {
-        int i = hand == HandSide.RIGHT ? 1 : -1;
+    	if(swingProgress == 0) return;
+    	//VIVE TODO: SOMETHING
+    	int i = hand == HandSide.RIGHT ? 1 : -1;
         float f = MathHelper.sin(swingProgress * swingProgress * (float)Math.PI);
-        GlStateManager.rotatef((float)i * (45.0F + f * -20.0F), 0.0F, 1.0F, 0.0F);
-        float f1 = MathHelper.sin(MathHelper.sqrt(swingProgress) * (float)Math.PI);
-        GlStateManager.rotatef((float)i * f1 * -20.0F, 0.0F, 0.0F, 1.0F);
-        GlStateManager.rotatef(f1 * -80.0F, 1.0F, 0.0F, 0.0F);
-        GlStateManager.rotatef((float)i * -45.0F, 0.0F, 1.0F, 0.0F);
+    	//  GlStateManager.rotate((float)i * (45.0F + f * -20.0F), 0.0F, 1.0F, 0.0F);
+    	float f1 = 0.5f * MathHelper.sin(MathHelper.sqrt(swingProgress) * (float)Math.PI);
+    	float 	f2= MathHelper.sin((float) (swingProgress *3*Math.PI));
+    	if(swingProgress > 0.5) {
+    		f2= MathHelper.sin((float) (swingProgress *Math.PI + Math.PI));
+    	}
+    	GlStateManager.translatef(0,0,-f1);
+    	//        GlStateManager.rotate((float)i * f1 * -20.0F, 0.0F, 0.0F, 1.0F);
+    	GlStateManager.rotatef((f2) * 45.0F  , 1.0F, 0.0F, 0.0F);
+    	//        GlStateManager.rotate((float)i * -45.0F, 0.0F, 1.0F, 0.0F);
     }
 
     private void transformSideFirstPerson(HandSide hand, float equippedProg)
     {
+    	/*Vivecraft
         int i = hand == HandSide.RIGHT ? 1 : -1;
         GlStateManager.translatef((float)i * 0.56F, -0.52F + equippedProg * -0.6F, -0.72F);
+        */
     }
 
     /**
@@ -399,183 +479,342 @@
         RenderHelper.disableStandardItemLighting();
     }
 
+    private enum VivecraftItemRendering{
+    	Item,
+    	Block,
+    	Shield,
+    	Sword,
+    	Tool,
+    	Bow,
+    	Spear,
+    	Map,
+    	Noms,
+    	Crossbow
+    }
+    
     public void renderItemInFirstPerson(AbstractClientPlayerEntity player, float partialTicks, float pitch, Hand hand, float swingProgress, ItemStack stack, float equippedProgress)
     {
-        if (!Config.isShaders() || !Shaders.isSkipRenderHand(hand))
-        {
-            boolean flag = hand == Hand.MAIN_HAND;
-            HandSide handside = flag ? player.getPrimaryHand() : player.getPrimaryHand().opposite();
-            GlStateManager.pushMatrix();
+    	boolean mainHand = hand == Hand.MAIN_HAND;
+    	HandSide HandSide = mainHand ? player.getPrimaryHand() : player.getPrimaryHand().opposite();
+    	equippedProgress = getEquipProgress(hand, partialTicks);
 
-            if (stack.isEmpty())
-            {
-                if (flag && !player.isInvisible())
-                {
-                    this.renderArmFirstPerson(equippedProgress, swingProgress, handside);
-                }
-            }
-            else if (stack.getItem() instanceof FilledMapItem)
-            {
-                if (flag && this.itemStackOffHand.isEmpty())
-                {
-                    this.renderMapFirstPerson(pitch, equippedProgress, swingProgress);
-                }
-                else
-                {
-                    this.renderMapFirstPersonSide(equippedProgress, handside, swingProgress, stack);
-                }
-            }
-            else if (stack.getItem() == Items.CROSSBOW)
-            {
-                boolean flag1 = CrossbowItem.isCharged(stack);
-                boolean flag2 = handside == HandSide.RIGHT;
-                int i = flag2 ? 1 : -1;
+    	boolean shouldrenderhand = true;
+    	if(mc.currentPass == RenderPass.THIRD && mc.vrSettings.mixedRealityRenderHands == false)
+    		shouldrenderhand = false;
 
-                if (player.isHandActive() && player.getItemInUseCount() > 0 && player.getActiveHand() == hand)
-                {
-                    this.transformSideFirstPerson(handside, equippedProgress);
-                    GlStateManager.translatef((float)i * -0.4785682F, -0.094387F, 0.05731531F);
-                    GlStateManager.rotatef(-11.935F, 1.0F, 0.0F, 0.0F);
-                    GlStateManager.rotatef((float)i * 65.3F, 0.0F, 1.0F, 0.0F);
-                    GlStateManager.rotatef((float)i * -9.785F, 0.0F, 0.0F, 1.0F);
-                    float f9 = (float)stack.getUseDuration() - ((float)this.mc.player.getItemInUseCount() - partialTicks + 1.0F);
-                    float f12 = f9 / (float)CrossbowItem.func_220026_e(stack);
+    	if(BowTracker.isBow(stack))
+    		shouldrenderhand = false;
 
-                    if (f12 > 1.0F)
-                    {
-                        f12 = 1.0F;
-                    }
 
-                    if (f12 > 0.1F)
-                    {
-                        float f15 = MathHelper.sin((f9 - 0.1F) * 1.3F);
-                        float f3 = f12 - 0.1F;
-                        float f4 = f15 * f3;
-                        GlStateManager.translatef(f4 * 0.0F, f4 * 0.004F, f4 * 0.0F);
-                    }
+    	if (shouldrenderhand && !player.isInvisible())
+        {
+    		this.renderArmFirstPerson(equippedProgress, player.swingingHand == hand ? swingProgress : 0, HandSide);
+    	}
+
+    	if(stack!=null && stack.isEmpty() == false){
 
-                    GlStateManager.translatef(f12 * 0.0F, f12 * 0.0F, f12 * 0.04F);
-                    GlStateManager.scalef(1.0F, 1.0F, 1.0F + f12 * 0.2F);
-                    GlStateManager.rotatef((float)i * 45.0F, 0.0F, -1.0F, 0.0F);
+            GlStateManager.pushMatrix();
+
+    		Item item = stack.getItem();
+    		VivecraftItemRendering rendertype = VivecraftItemRendering.Item;
+
+    		if(item instanceof BlockItem)
+    			rendertype = VivecraftItemRendering.Block;
+    		else if(item instanceof AbstractMapItem)
+    			rendertype = VivecraftItemRendering.Map;
+    		else if (stack.getUseAction() == UseAction.BOW)
+    			rendertype = VivecraftItemRendering.Bow;
+    		else if(item instanceof SwordItem)
+    			rendertype = VivecraftItemRendering.Sword;
+    		else if(item instanceof ShieldItem)
+    			rendertype = VivecraftItemRendering.Shield;
+    		else if(item instanceof TridentItem)
+    			rendertype = VivecraftItemRendering.Spear;
+    		else if(item instanceof CrossbowItem)
+    			rendertype = VivecraftItemRendering.Crossbow;
+    		else if(stack.getUseAction() == UseAction.EAT || stack.getUseAction() == UseAction.DRINK)
+    			rendertype = VivecraftItemRendering.Noms;
+    		else if(SwingTracker.isTool(item))
+    			rendertype = VivecraftItemRendering.Tool;
+
+    		boolean rightSide = HandSide == HandSide.RIGHT;
+    		int i = rightSide ? 1 : -1;
+    		float f = -0.4F * MathHelper.sin(MathHelper.sqrt(swingProgress) * (float)Math.PI);
+    		float f1 = 0.2F * MathHelper.sin(MathHelper.sqrt(swingProgress) * ((float)Math.PI * 2F));
+    		float f2 = -0.2F * MathHelper.sin(swingProgress * (float)Math.PI);
+    		boolean vive = !MCOpenVR.isGunStyle();
+    		boolean skipActualItem = false;
+    		
+    		{ //animations
+    			if(player.swingingHand == hand)
+    				this.transformFirstPerson(HandSide, swingProgress);	
+    		}
+    		
+    		switch (rendertype) {
+    		case Block:
+    			Block b = ((BlockItem) item).getBlock(); 
+    			if (this.itemRenderer.shouldRenderItemIn3D(stack)){
+    				GlStateManager.translatef(0f, 0f, -0.1f);	
+    				GlStateManager.scaled(0.2, 0.2, 0.2);
+				}else if(b instanceof TorchBlock || b instanceof BambooBlock) {
+    				GlStateManager.translatef(0f, 0.05f, -0.2f);		
+    				GlStateManager.scaled(0.6, 0.6, 0.6);	
+    				GlStateManager.rotatef(90.0F, 0.0F, 1.0F, 0.0F);
+    				GlStateManager.rotatef(-75.0F, 0.0F, 0.0F, 1.0F);    
+    			}else{
+    				GlStateManager.translatef(0f, 0f, -0.15f);		
+    				GlStateManager.scaled(0.3, 0.3, 0.3);
+    				GlStateManager.rotatef(-i*45.0F, 0.0F, 1.0F, 0.0F);   
                 }
-                else
-                {
-                    float f = -0.4F * MathHelper.sin(MathHelper.sqrt(swingProgress) * (float)Math.PI);
-                    float f1 = 0.2F * MathHelper.sin(MathHelper.sqrt(swingProgress) * ((float)Math.PI * 2F));
-                    float f2 = -0.2F * MathHelper.sin(swingProgress * (float)Math.PI);
-                    GlStateManager.translatef((float)i * f, f1, f2);
-                    this.transformSideFirstPerson(handside, equippedProgress);
-                    this.transformFirstPerson(handside, swingProgress);
+    			break;
+    		case Bow:
+    			GlStateManager.scalef(1.0f, 1.0f, 1.0f);
+    			if(mc.bowTracker.isActive((ClientPlayerEntity) player)) {
+    				if(mc.bowTracker.isDrawing){ //here there be dragons
+
+    					int c = 0;
+    					if (mc.vrSettings.vrReverseShootingEye) c = 1;
+
+    					Vec3d aim = mc.bowTracker.getAimVector(); 
+    					Vec3d a = new Vec3d(aim.x, aim.y, aim.z);			
+
+    					Vec3d lup = mc.vrPlayer.vrdata_world_render.getController(1).getCustomVector(new Vec3d(0, -1, 0));
+    					Vec3d lback = mc.vrPlayer.vrdata_world_render.getController(1).getCustomVector(new Vec3d(0, 0, -1));
+
+    					Vec3d v = a.crossProduct(lup);
+    					double d = 180 / Math.PI * Math.acos(a.dotProduct(lup));
+
+    					float aimpitch = (float)Math.toDegrees(Math.asin(a.y/a.length()));
+    					float yaw = (float)Math.toDegrees(Math.atan2(a.x, a.z));     
+
+    					Vec3d up = new Vec3d(0,1,0);
+
+    					Vec3d ahz = new Vec3d(a.x, 0, a.z); // we want the normal to a aiming plane, but vertical.
+    					Vec3d pAim2 = Vec3d.ZERO;
+
+    					double porjaim = lback.dotProduct(ahz); //angle between controller up and aim, just for ortho check			    		        		
+    					if(porjaim !=0) { //check to make sure 	we arent holding the bow perfectly straight up.					
+    						pAim2 = ahz.scale(porjaim);	 //projection of l_controller_up onto aim vector ... why is there no multiply?		        	 
+    					}
+
+    					double dot =0;
+
+    					Vec3d proj = lback.subtract(pAim2).normalize();
+
+    					dot = proj.dotProduct(up);		//angle between our projection and straight up (the default bow render pos.)
+
+    					double dot2 = ahz.dotProduct(proj.crossProduct(up)); //angle sign test, negative is left roll
+
+    					float angle;
+
+    					if (dot2 < 0) 
+    						angle = -(float) Math.acos(dot);  	
+    					else angle = (float) Math.acos(dot); 
+
+    					float roll = (float) (180 / Math.PI * angle);     //calulate bow model roll.
+
+    					GlStateManager.rotatef(yaw, 0.0F,1.0F, 0.0F);
+    					GlStateManager.rotatef(-aimpitch, 1.0F, 0.0F, 0.0F);
+
+    					GlStateManager.rotatef(-roll, 0.0F, 0.0F, 1.0F);  
+    					GlStateManager.rotatef(90f, 1.0F, 0.0F, 0.0F);    
+    					//	GlStateManager.rotate(-180.0F, 0.0F, 0.0F, 1.0F);	
+
+    					if(mc.bowTracker.isCharged()){
+    						long t = Util.milliTime() - mc.bowTracker.startDrawTime;
+    						GlStateManager.translated(0.003*Math.sin(t),0, 0);
+    					}
+    					GlStateManager.scaled(1,mc.bowTracker.getDrawPercent()*0.15+1,1);
+    				}
+    				else if(mc.vrSettings.seated){
+    					GlStateManager.scalef(0.5f,0.5f,0.5f);    
+    					GlStateManager.rotatef(90f, 1.0F, 0.0F, 0.0F);    
+    				}
+
+    				if(vive || mc.bowTracker.isDrawing){
+    					GlStateManager.translated(-0.012, 0.2, 00);
+    					GlStateManager.rotatef(-45F, 1.0F, 0.0F, 0.0F);
+    				} else {
+    					GlStateManager.translated(-0.012, 0.17, .100);
+    					GlStateManager.rotatef(-45F + 39.4f, 1.0F, 0.0F, 0.0F	);
+    				}
+
+    				GlStateManager.rotatef(-90.0F, 0.0F, 1.0F, 0.0F);
+    				GlStateManager.rotatef(90.0F, 0.0F, 0.0F, 1.0F);	
+
+    			}
+    			else {
+    				//roomscale bow off
+    				GlStateManager.scalef(0.5f,0.5f,0.5f);    
+    				GlStateManager.rotatef(90f, 1.0F, 0.0F, 0.0F);    
+
+    				GlStateManager.translated(-0.012, 0.2, 00);
+    				GlStateManager.rotatef(-45F, 1.0F, 0.0F, 0.0F);
+
+    				GlStateManager.rotatef(-90.0F, 0.0F, 1.0F, 0.0F);
+    				GlStateManager.rotatef(90.0F, 0.0F, 0.0F, 1.0F);	
+    			}
+    			break;
+    		case Item:
+    			GlStateManager.translatef(0f, 0f, -0.1f);		
+    			GlStateManager.scaled(0.3, 0.3, 0.3);
+    			GlStateManager.rotatef(-i*45.0F, 0.0F, 1.0F, 0.0F);
+    			break;
+    		case Map:
+    			skipActualItem = true;
+    			this.renderMapFirstPersonSide(equippedProgress, HandSide, swingProgress, stack);
+    			break;
+    		case Shield:
 
-                    if (flag1 && swingProgress < 0.001F)
+    			GlStateManager.scaled(1.2, 1.2, 1.2);
+                if (player.isHandActive() && player.getItemInUseCount() > 0 && player.getActiveHand() == hand)
                     {
-                        GlStateManager.translatef((float)i * -0.641864F, 0.0F, 0.0F);
-                        GlStateManager.rotatef((float)i * 10.0F, 0.0F, 1.0F, 0.0F);
+	    			if(player.isActiveItemStackBlocking()){
+	    				GlStateManager.rotatef(i*90.0F, 0.0F, 1.0F, 0.0F);  
+	    			} else{
+	    				GlStateManager.rotatef((1-equippedProgress)*i*90.0F, 0.0F, 1.0F, 0.0F);
                     }
                 }
 
-                this.renderItemSide(player, stack, flag2 ? ItemCameraTransforms.TransformType.FIRST_PERSON_RIGHT_HAND : ItemCameraTransforms.TransformType.FIRST_PERSON_LEFT_HAND, !flag2);
-            }
-            else
-            {
-                boolean flag3 = handside == HandSide.RIGHT;
-
+    			GlStateManager.scaled(0.4, 0.4, 0.4);
+    			GlStateManager.rotatef(i*90.0F, 0.0F, 1.0F, 0.0F);  
+    			GlStateManager.translated(.5,0.5,.6);
+
+    			break;
+    		case Spear:
+
+				float prog = 0;
+				boolean charging = false;
+				int j = 0;
                 if (player.isHandActive() && player.getItemInUseCount() > 0 && player.getActiveHand() == hand)
                 {
-                    int k = flag3 ? 1 : -1;
-
-                    switch (stack.getUseAction())
-                    {
-                        case NONE:
-                            this.transformSideFirstPerson(handside, equippedProgress);
-                            break;
-
-                        case EAT:
-                        case DRINK:
-                            this.transformEatFirstPerson(partialTicks, handside, stack);
-                            this.transformSideFirstPerson(handside, equippedProgress);
-                            break;
+					charging = true;
+					j = EnchantmentHelper.getRiptideModifier(stack);
 
-                        case BLOCK:
-                            this.transformSideFirstPerson(handside, equippedProgress);
-                            break;
-
-                        case BOW:
-                            this.transformSideFirstPerson(handside, equippedProgress);
-                            GlStateManager.translatef((float)k * -0.2785682F, 0.18344387F, 0.15731531F);
-                            GlStateManager.rotatef(-13.935F, 1.0F, 0.0F, 0.0F);
-                            GlStateManager.rotatef((float)k * 35.3F, 0.0F, 1.0F, 0.0F);
-                            GlStateManager.rotatef((float)k * -9.785F, 0.0F, 0.0F, 1.0F);
-                            float f8 = (float)stack.getUseDuration() - ((float)this.mc.player.getItemInUseCount() - partialTicks + 1.0F);
-                            float f11 = f8 / 20.0F;
-                            f11 = (f11 * f11 + f11 * 2.0F) / 3.0F;
-
-                            if (f11 > 1.0F)
-                            {
-                                f11 = 1.0F;
+					if(j<=0 || (j>0 &&player.isWet())){
+						prog = (float)stack.getUseDuration() - ((float)this.mc.player.getItemInUseCount() - partialTicks + 1.0F);
+						if (prog > 10) { //charged    
+							prog = 10;
+
+							if (j>0 && player.isWet()) {                
+								GlStateManager.rotatef((-mc.tickCounter*10*j) % 360 - partialTicks*10*j , 0.0F, 0.0F, 1.0F);      							
+							} 
+
+							if(mc.frameIndex % 4 == 0) {
+								MCOpenVR.triggerHapticPulse(mainHand ? 0 : 1, 200);
+							}	   	
+
+							long t = Util.milliTime() - mc.bowTracker.startDrawTime;
+							GlStateManager.translated(0.003*Math.sin(t),0, 0);  						
+						}
+					} 	
+				}
+
+                if(player.isSpinAttacking()) {
+                	j = 5;
+        			GlStateManager.translated(0 ,0, -0.15f);  	
+					GlStateManager.rotatef((-mc.tickCounter*10*j) % 360 - partialTicks*10*j , 0.0F, 0.0F, 1.0F);      							
+        			charging = true;
                             }
 
-                            if (f11 > 0.1F)
-                            {
-                                float f14 = MathHelper.sin((f8 - 0.1F) * 1.3F);
-                                float f17 = f11 - 0.1F;
-                                float f19 = f14 * f17;
-                                GlStateManager.translatef(f19 * 0.0F, f19 * 0.004F, f19 * 0.0F);
+				if(!vive && !charging) {
+    				GlStateManager.rotatef(39.4f, 1.0F, 0.0F, 0.0F);
                             }
 
-                            GlStateManager.translatef(f11 * 0.0F, f11 * 0.0F, f11 * 0.04F);
-                            GlStateManager.scalef(1.0F, 1.0F, 1.0F + f11 * 0.2F);
-                            GlStateManager.rotatef((float)k * 45.0F, 0.0F, -1.0F, 0.0F);
+                GlStateManager.translatef(0.3f, -0.3f, -0.75f + prog /10 * (0.25f) );		
+				GlStateManager.scaled(0.6, 0.6, 0.6);	
+				GlStateManager.rotatef(90.0F, 0.0F, 1.0F, 0.0F);   
+				GlStateManager.rotatef(-90.0F, 0.0F, 0.0F, 1.0F);     
                             break;
+    		case Sword:
+    			if(vive){
+    				GlStateManager.translatef(0f, 0f, -0.2f);		
+    				GlStateManager.scaled(0.6, 0.6, 0.6);	
+    				GlStateManager.rotatef(-45F, 1.0F, 0.0F, 0.0F);
+    				GlStateManager.rotatef(90.0F, 0.0F, 1.0F, 0.0F);      							
+    			} else {
+    				GlStateManager.translatef(0f, 0.10f, -0.125f);		
+    				GlStateManager.scaled(0.6, 0.6, 0.6);	
+    				GlStateManager.rotatef(-45F + 39.4f, 1.0F, 0.0F, 0.0F);
+    				GlStateManager.rotatef(90.0F, 0.0F, 1.0F, 0.0F);  
+    			}
+    			break;
+    		case Crossbow:
+    			
+//    			if(!vive) {
+//    				GlStateManager.rotatef(39.4f, 1.0F, 0.0F, 0.0F);
+//    			}
+    			
+				GlStateManager.translatef(0, .06f, -0.1f);
+
+    			GlStateManager.scaled(0.5, 0.5, 0.5);	
+        		GlStateManager.rotatef(-90.0F, 1.0F, 0.0F, 0.0F);   
+
+    			GlStateManager.rotatef(-45.0F, 0.0F, 0.0F, 1.0F); 
+    		//	GlStateManager.rotatef(45.0F, 1.0F, 0.0F, 0.0F);   
+    			break;
+    		case Tool:
+
+    			boolean climbClaws = mc.climbTracker.isClaws(stack) && mc.climbTracker.isClimbeyClimb();
+
+    			if(climbClaws){
+
+    				GlStateManager.scaled(0.3, 0.3, 0.3);
+    				GlStateManager.translatef(-.025f, .12f, .25f);
+    				GlStateManager.rotatef(90, 0, 0, 1);	
+
+    				if((MCOpenVR.keyClimbeyGrab.isKeyDown(ControllerType.RIGHT) && rightSide) || (MCOpenVR.keyClimbeyGrab.isKeyDown(ControllerType.LEFT) && !rightSide)) {
+    					GlStateManager.translatef(0f, 0f, -.2f);	
+    				}
+    			}
+
+    			if(vive || climbClaws){
+    				GlStateManager.translatef(0f, -.025f, -0.1f);		
+    				GlStateManager.scaled(0.6, 0.6, 0.6);	
+
+    				if(item instanceof CarrotOnAStickItem || item instanceof FishingRodItem) {}
+    				else
+    					GlStateManager.rotatef(180.0F, 0.0F, 0.0F, 1.0F);  
+
+    				GlStateManager.rotatef(-45F, 1.0F, 0.0F, 0.0F);
+    				GlStateManager.rotatef(90.0F, 0.0F, 1.0F, 0.0F);
+    			} else {
+    				GlStateManager.translatef(0f, 0.035f, -0.1f);		
+    				GlStateManager.scaled(0.6, 0.6, 0.6);	
 
-                        case SPEAR:
-                            this.transformSideFirstPerson(handside, equippedProgress);
-                            GlStateManager.translatef((float)k * -0.5F, 0.7F, 0.1F);
-                            GlStateManager.rotatef(-55.0F, 1.0F, 0.0F, 0.0F);
-                            GlStateManager.rotatef((float)k * 35.3F, 0.0F, 1.0F, 0.0F);
-                            GlStateManager.rotatef((float)k * -9.785F, 0.0F, 0.0F, 1.0F);
-                            float f13 = (float)stack.getUseDuration() - ((float)this.mc.player.getItemInUseCount() - partialTicks + 1.0F);
-                            float f16 = f13 / 10.0F;
-
-                            if (f16 > 1.0F)
-                            {
-                                f16 = 1.0F;
+    				if(item instanceof CarrotOnAStickItem || item instanceof FishingRodItem) {
+    					GlStateManager.rotatef(39.4f, 1.0F, 0.0F, 0.0F);
                             }
+    				else
+    					GlStateManager.rotatef(180.0F, 0.0F, 0.0F, 1.0F);  
 
-                            if (f16 > 0.1F)
-                            {
-                                float f18 = MathHelper.sin((f13 - 0.1F) * 1.3F);
-                                float f20 = f16 - 0.1F;
-                                float f5 = f18 * f20;
-                                GlStateManager.translatef(f5 * 0.0F, f5 * 0.004F, f5 * 0.0F);
-                            }
-
-                            GlStateManager.translatef(0.0F, 0.0F, f16 * 0.2F);
-                            GlStateManager.scalef(1.0F, 1.0F, 1.0F + f16 * 0.2F);
-                            GlStateManager.rotatef((float)k * 45.0F, 0.0F, -1.0F, 0.0F);
-                    }
-                }
-                else if (player.isSpinAttacking())
+    				GlStateManager.rotatef(-45F - 39.4f, 1.0F, 0.0F, 0.0F);
+    				GlStateManager.rotatef(90.0F, 0.0F, 1.0F, 0.0F);
+    			}
+    			
+    			break;
+    		case Noms:
+                if (player.isHandActive() && player.getItemInUseCount() > 0 && player.getActiveHand() == hand)
                 {
-                    this.transformSideFirstPerson(handside, equippedProgress);
-                    int j = flag3 ? 1 : -1;
-                    GlStateManager.translatef((float)j * -0.4F, 0.8F, 0.3F);
-                    GlStateManager.rotatef((float)j * 65.0F, 0.0F, 1.0F, 0.0F);
-                    GlStateManager.rotatef((float)j * -85.0F, 0.0F, 0.0F, 1.0F);
+                	this.transformEatFirstPerson(partialTicks, HandSide, stack);
                 }
-                else
-                {
-                    float f6 = -0.4F * MathHelper.sin(MathHelper.sqrt(swingProgress) * (float)Math.PI);
-                    float f7 = 0.2F * MathHelper.sin(MathHelper.sqrt(swingProgress) * ((float)Math.PI * 2F));
-                    float f10 = -0.2F * MathHelper.sin(swingProgress * (float)Math.PI);
-                    int l = flag3 ? 1 : -1;
-                    GlStateManager.translatef((float)l * f6, f7, f10);
-                    this.transformSideFirstPerson(handside, equippedProgress);
-                    this.transformFirstPerson(handside, swingProgress);
+    			GlStateManager.translatef(0f, 0f, -0.1f);		
+    			GlStateManager.scaled(0.3, 0.3, 0.3);
+    			GlStateManager.rotatef(-i*45.0F, 0.0F, 1.0F, 0.0F);
+    			break;
                 }
 
-                this.renderItemSide(player, stack, flag3 ? ItemCameraTransforms.TransformType.FIRST_PERSON_RIGHT_HAND : ItemCameraTransforms.TransformType.FIRST_PERSON_LEFT_HAND, !flag3);
-            }
+    		this.itemRenderer.ismainhand = mainHand;
+    		this.itemRenderer.isfphand = true;
+
+    		//VIVE use 'NONE' transforms.
+//    		if(!thing)
+    		if (!skipActualItem) this.renderItemSide(player, stack, rightSide ? ItemCameraTransforms.TransformType.NONE : ItemCameraTransforms.TransformType.NONE, !rightSide);
+//    		else
+//    			this.renderItemSide(player, stack, rightSide ? ItemCameraTransforms.TransformType.THIRD_PERSON_RIGHT_HAND : ItemCameraTransforms.TransformType.THIRD_PERSON_LEFT_HAND, !rightSide);
+
+    		this.itemRenderer.ismainhand = false;
+    		this.itemRenderer.isfphand = false;
 
             GlStateManager.popMatrix();
         }
@@ -586,49 +825,59 @@
      */
     public void renderOverlays(float partialTicks)
     {
+    	//Vivecraft
+      	mc.gameRenderer.inportal = false;
+    	mc.gameRenderer.inwater = false;
+    	mc.gameRenderer.inblock = false;
+    	mc.gameRenderer.onfire = false;
+    	//
+    	
         GlStateManager.disableAlphaTest();
+        Vec3d pos = mc.vrPlayer.vrdata_world_render.getEye(mc.currentPass).getPosition();
+        BlockPos bp = new BlockPos(pos.add(mc.vrPlayer.vrdata_world_render.hmd.getDirection().scale(0.1)));
+    	BlockState BlockState = this.mc.world.getBlockState(bp);
+
+        if (BlockState.causesSuffocation(mc.world,bp) && BlockState.getRenderType() != BlockRenderType.INVISIBLE) //TODO: Test if RVE override makes this work correctly.
+        {
+
+        	TextureAtlasSprite tex = this.mc.getBlockRendererDispatcher().getBlockModelShapes().getTexture(BlockState);
+        	this.renderFaceInBlock();
+        	mc.gameRenderer.inblock = true;
+        	mc.gameRenderer.renderVRGuiElements(false, partialTicks);
+
+        	//            BlockState BlockState = this.mc.world.getBlockState(new BlockPos(this.mc.player));
+        	//            BlockPos blockpos = new BlockPos(this.mc.player);
+        	//            EntityPlayer entityplayer = this.mc.player;
+
+        	//            for (int i = 0; i < 8; ++i)
+        	//            {
+        	//                double d0 = entityplayer.posX + (double)(((float)((i >> 0) % 2) - 0.5F) * entityplayer.width * 0.8F);
+        	//                double d1 = entityplayer.posY + (double)(((float)((i >> 1) % 2) - 0.5F) * 0.1F);
+        	//                double d2 = entityplayer.posZ + (double)(((float)((i >> 2) % 2) - 0.5F) * entityplayer.width * 0.8F);
+        	//                BlockPos blockpos1 = new BlockPos(d0, d1 + (double)entityplayer.getEyeHeight(), d2);
+        	//                BlockState BlockState1 = this.mc.world.getBlockState(blockpos1);
+        	//
+        	//                if (BlockState1.causesSuffocation())
+        	//                {
+        	//                    BlockState = BlockState1;
+        	//                    blockpos = blockpos1;
+        	//                }
+        	//            }
 
-        if (this.mc.player.isEntityInsideOpaqueBlock())
-        {
-            BlockState blockstate = this.mc.world.getBlockState(new BlockPos(this.mc.player));
-            BlockPos blockpos = new BlockPos(this.mc.player);
-            PlayerEntity playerentity = this.mc.player;
-
-            for (int i = 0; i < 8; ++i)
-            {
-                double d0 = playerentity.posX + (double)(((float)((i >> 0) % 2) - 0.5F) * playerentity.getWidth() * 0.8F);
-                double d1 = playerentity.posY + (double)(((float)((i >> 1) % 2) - 0.5F) * 0.1F);
-                double d2 = playerentity.posZ + (double)(((float)((i >> 2) % 2) - 0.5F) * playerentity.getWidth() * 0.8F);
-                BlockPos blockpos1 = new BlockPos(d0, d1 + (double)playerentity.getEyeHeight(), d2);
-                BlockState blockstate1 = this.mc.world.getBlockState(blockpos1);
 
-                if (blockstate1.causesSuffocation(this.mc.world, blockpos1))
-                {
-                    blockstate = blockstate1;
-                    blockpos = blockpos1;
-                }
-            }
-
-            if (blockstate.getRenderType() != BlockRenderType.INVISIBLE)
-            {
-                Object object = Reflector.getFieldValue(Reflector.RenderBlockOverlayEvent_OverlayType_BLOCK);
-
-                if (!Reflector.callBoolean(Reflector.ForgeEventFactory_renderBlockOverlay, this.mc.player, partialTicks, object, blockstate, blockpos))
-                {
-                    this.renderSuffocationOverlay(this.mc.getBlockRendererDispatcher().getBlockModelShapes().getTexture(blockstate));
-                }
-            }
         }
 
         if (!this.mc.player.isSpectator())
         {
             if (this.mc.player.areEyesInFluid(FluidTags.WATER) && !Reflector.callBoolean(Reflector.ForgeEventFactory_renderWaterOverlay, this.mc.player, partialTicks))
             {
-                this.renderWaterOverlayTexture(partialTicks);
+            	mc.gameRenderer.inwater = true;
+                //this.renderWaterOverlayTexture(partialTicks);
             }
 
             if (this.mc.player.isBurning() && !Reflector.callBoolean(Reflector.ForgeEventFactory_renderFireOverlay, this.mc.player, partialTicks))
             {
+            	mc.gameRenderer.onfire = true;
                 this.renderFireInFirstPerson();
             }
         }
@@ -710,13 +959,13 @@
         Tessellator tessellator = Tessellator.getInstance();
         BufferBuilder bufferbuilder = tessellator.getBuffer();
         GlStateManager.color4f(1.0F, 1.0F, 1.0F, 0.9F);
-        GlStateManager.depthFunc(519);
-        GlStateManager.depthMask(false);
+        //GlStateManager.depthFunc(519);
+        //GlStateManager.depthMask(false);
         GlStateManager.enableBlend();
         GlStateManager.blendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
         float f = 1.0F;
 
-        for (int i = 0; i < 2; ++i)
+        for (int i = 0; i < 4; ++i)
         {
             GlStateManager.pushMatrix();
             TextureAtlasSprite textureatlassprite = this.mc.getTextureMap().getSprite(ModelBakery.LOCATION_FIRE_1);
@@ -725,19 +974,20 @@
             float f2 = textureatlassprite.getMaxU();
             float f3 = textureatlassprite.getMinV();
             float f4 = textureatlassprite.getMaxV();
-            float f5 = -0.5F;
-            float f6 = 0.5F;
-            float f7 = -0.5F;
-            float f8 = 0.5F;
-            float f9 = -0.5F;
-            GlStateManager.translatef((float)(-(i * 2 - 1)) * 0.24F, -0.3F, 0.0F);
-            GlStateManager.rotatef((float)(i * 2 - 1) * 10.0F, 0.0F, 1.0F, 0.0F);
+
+            GlStateManager.rotatef((float)(i * 90.0F - mc.vrPlayer.vrdata_world_render.getBodyYaw()), 0.0F, 1.0F, 0.0F);
+            float f5 = 0.3f;  
+            float f6 = (float) (mc.vrPlayer.vrdata_world_render.hmd.getPosition().y - mc.gameRenderer.rveY);
+            GlStateManager.translatef(0, -f6, 0.0F);
+
             bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX);
             bufferbuilder.setSprite(textureatlassprite);
-            bufferbuilder.pos(-0.5D, -0.5D, -0.5D).tex((double)f2, (double)f4).endVertex();
-            bufferbuilder.pos(0.5D, -0.5D, -0.5D).tex((double)f1, (double)f4).endVertex();
-            bufferbuilder.pos(0.5D, 0.5D, -0.5D).tex((double)f1, (double)f3).endVertex();
-            bufferbuilder.pos(-0.5D, 0.5D, -0.5D).tex((double)f2, (double)f3).endVertex();
+
+            bufferbuilder.pos(-f5, 0, -f5).tex((double)f2, (double)f4).endVertex();
+            bufferbuilder.pos(f5, 0, -f5).tex((double)f1, (double)f4).endVertex();
+            bufferbuilder.pos(f5, f6, -f5).tex((double)f1, (double)f3).endVertex();
+            bufferbuilder.pos(-f5, f6, -f5).tex((double)f2, (double)f3).endVertex();
+            
             tessellator.draw();
             GlStateManager.popMatrix();
         }
@@ -822,4 +1072,130 @@
             this.equippedProgressOffHand = 0.0F;
         }
     }
+    
+    //VIVECRAFT ADDITIONS
+    public float getEquipProgress(Hand hand, float partialTicks){
+    	if(hand == Hand.MAIN_HAND)
+    		return 1.0f- (this.prevEquippedProgressMainHand + (this.equippedProgressMainHand - this.prevEquippedProgressMainHand) * partialTicks);
+    	else
+    		return 1.0F - (this.prevEquippedProgressOffHand + (this.equippedProgressOffHand - this.prevEquippedProgressOffHand) * partialTicks);
+    }
+
+    private void renderFaceInBlock() {
+        Tessellator tessellator = Tessellator.getInstance();
+        BufferBuilder bufferbuilder = tessellator.getBuffer();
+        
+        GlStateManager.color4f(0f, 0F, 0F, mc.gameRenderer.inBlock);
+        
+        GlStateManager.matrixMode(GL11.GL_PROJECTION);
+        GlStateManager.pushMatrix();
+	        GlStateManager.ortho(0.0D, 1, 0, 1, 0, 100);
+	        GlStateManager.matrixMode(GL11.GL_MODELVIEW);
+	        GlStateManager.pushMatrix();
+		        GlStateManager.loadIdentity();
+		        
+		        GlStateManager.disableDepthTest();
+		        GlStateManager.disableTexture();
+		        GlStateManager.enableBlend();	               
+	       
+		        bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX);
+		        bufferbuilder.pos(-1 ,-1, 0).endVertex();
+		        bufferbuilder.pos(2, -1, 0).endVertex();
+		        bufferbuilder.pos(2, 2, 0).endVertex();
+		        bufferbuilder.pos(-1, 2, 0).endVertex();
+		        tessellator.draw();
+		        
+
+	        GlStateManager.matrixMode(GL11.GL_PROJECTION);
+	        GlStateManager.popMatrix();
+        GlStateManager.matrixMode(GL11.GL_MODELVIEW);
+        GlStateManager.popMatrix();
+        
+        //GlStateManager.enableDepth();
+        GlStateManager.enableTexture();
+        GlStateManager.color4f(1.0F, 1.0F, 1.0F, 1.0F);
+    }
+    
+    public boolean isInsideOpaqueBlock(Vec3d in, boolean set)
+    {
+
+    	if (mc.world == null) return false;
+    	BlockPos bp = new BlockPos(in);
+    	
+    	if(mc.world.getBlockState(bp).causesSuffocation(mc.world, bp)) {
+    		mc.gameRenderer.inBlock = 1;
+    		return true;
+    	}
+    	
+    	if(!set) return false;
+    	mc.gameRenderer.inBlock = 0;    	
+    	Vec3d pos = in.add(0, 0, 0);
+    	float per = 0;
+    	float buffer = .07f;	
+    	
+    	if((pos.x - Math.floor(pos.x)) < buffer) 
+    	{
+    		per = (float) (pos.x - Math.floor(pos.x));
+    		mc.gameRenderer.inBlock = (buffer - per) / buffer; 
+    		if (mc.world.getBlockState(bp.west()).causesSuffocation(mc.world, bp.west())) return true;
+    	}
+    	
+    	if(pos.x - Math.floor(pos.x) > 1-buffer){
+    		per = 1f - (float) (pos.x - Math.floor(pos.x));
+    		mc.gameRenderer.inBlock = (buffer - per) / buffer; 
+    		if (mc.world.getBlockState(bp.east()).causesSuffocation(mc.world, bp.east())) return true;
+    	}
+    	
+    	if((pos.y - Math.floor(pos.y)) < buffer) 
+    	{
+    		per = (float) (pos.y - Math.floor(pos.y));
+    		mc.gameRenderer.inBlock = (buffer - per) / buffer; 
+    		if (mc.world.getBlockState(bp.down()).causesSuffocation(mc.world, bp.down())) return true;
+    	} 
+    	
+    	if(pos.y - Math.floor(pos.y) > 1-buffer){
+    		per = 1f - (float) (pos.y - Math.floor(pos.y));
+    		mc.gameRenderer.inBlock = (buffer - per) / buffer; 
+    		if (mc.world.getBlockState(bp.up()).causesSuffocation(mc.world,bp.up())) return true;
+    	}
+    	
+    	if((pos.z - Math.floor(pos.z)) < buffer) 
+    	{
+    		per = (float) (pos.z - Math.floor(pos.z));
+    		mc.gameRenderer.inBlock = (buffer - per) / buffer; 
+    		if (mc.world.getBlockState(bp.north()).causesSuffocation(mc.world, bp.north())) return true;
+    	} 
+    	
+    	if(pos.z - Math.floor(pos.z) > 1-buffer){
+    		per = 1f - (float) (pos.z - Math.floor(pos.z));
+    		mc.gameRenderer.inBlock = (buffer - per) / buffer; 
+    		if (mc.world.getBlockState(bp.south()).causesSuffocation(mc.world, bp.south())) return true;
+    	}
+
+    	return false;
+    	
+    }
+
+//    public boolean isInsideOfMaterial(Vec3d pos, Material materialIn)
+//    {
+//    	BlockPos blockpos = new BlockPos(pos);
+//    	BlockState BlockState = mc.world.getBlockState(blockpos);
+//    	BlockState BlockStateup = mc.world.getBlockState(blockpos.up());
+//
+//    	if (BlockState.getMaterial() == materialIn)
+//    	{
+//    		float f = BlockLiquid.getLiquidHeightPercent(BlockState.getBlock().getMetaFromState(BlockState)) -0.11111111F;;
+//    		if(BlockStateup.getMaterial() != materialIn && materialIn instanceof MaterialLiquid) f+=0.09F;
+//    		
+//    		//float f1 = (float)(blockpos.getY() + 1) - f;
+//    		boolean flag = (pos.y-blockpos.getY()) < (1-f);
+//    		return flag;
+//    	}
+//    	else
+//    	{
+//    		return false;
+//    	}
+//   }
+    //
+    
 }
